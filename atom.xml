<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wiki</title>
  
  <subtitle>my hearts will go on!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mayi21.github.io/"/>
  <updated>2020-04-04T05:00:49.350Z</updated>
  <id>https://mayi21.github.io/</id>
  
  <author>
    <name>Mayi21</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>资源合集</title>
    <link href="https://mayi21.github.io/2020/04/04/%E5%88%86%E4%BA%AB/"/>
    <id>https://mayi21.github.io/2020/04/04/分享/</id>
    <published>2020-04-04T03:18:07.410Z</published>
    <updated>2020-04-04T05:00:49.350Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="解放书签"><a href="#解放书签" class="headerlink" title="解放书签"></a>解放书签</h1><h2 id="1-无水印图片-自用"><a href="#1-无水印图片-自用" class="headerlink" title="1.无水印图片(自用)"></a>1.无水印图片(自用)</h2><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><a id="more"></a><h3 id="无水印图片"><a href="#无水印图片" class="headerlink" title="无水印图片"></a>无水印图片</h3><p><img src="https://www.johanadam.workers.dev/Image/Bolg/ReleaseBookMarks/TrafficTaurusLionelMajzik_2400.jpg" alt><br><a href="https://apod.nasa.gov/apod/archivepix.html" target="_blank" rel="noopener">Nasa</a>,这里会每天更新一张图片.<br><img src="https://www.johanadam.workers.dev/Image/Bolg/ReleaseBookMarks/woman-in-grey-sports-bra-and-leggings-3844000.jpg" alt><br><a href="https://www.pexels.com/" target="_blank" rel="noopener">pexels</a>,才华横溢的摄影作者在这里免费分享最精彩的素材照片和视频.<br><img src="https://www.johanadam.workers.dev/Image/Bolg/ReleaseBookMarks/vitae-london-Y4LM8e_3BhI-unsplash.jpg" alt><br><a href="https://unsplash.com/" target="_blank" rel="noopener">unsplash</a>,Photos for everyone.<br><img src="https://www.johanadam.workers.dev/Image/Bolg/ReleaseBookMarks/StockSnap_XO3LWF75UP.jpg" alt><br><a href="https://stocksnap.io/" target="_blank" rel="noopener">StockSnap.io</a>,Hundreds of high resolution images added weekly. Free from copyright restrictions.<br><img src="https://www.johanadam.workers.dev/Image/Bolg/ReleaseBookMarks/kaboompics_EnbeeWeddingGolden-Chrysanthemums.jpg" alt><br><a href="https://kaboompics.com/" target="_blank" rel="noopener">kaboompics</a>,LET’S FIND THE PERFECT PHOTO FOR YOU.<br><img src="https://www.johanadam.workers.dev/Image/Bolg/ReleaseBookMarks/autumn-2-1382506.jpg" alt><br><a href="https://cn.freeimages.com/" target="_blank" rel="noopener">FREEIMAGES</a><br><img src="https://www.johanadam.workers.dev/Image/Bolg/ReleaseBookMarks/fruits_high_res.jpg" alt><br><a href="http://www.designerspics.com/" target="_blank" rel="noopener">DesignersPics.com</a>,FREE Hi-Res photos for your personal &amp; commercial use.  Attribution not required!<br><img src="https://www.johanadam.workers.dev/Image/Bolg/ReleaseBookMarks/landscape-with-forest-in-snow.jpg" alt><br><a href="https://visualhunt.com/" target="_blank" rel="noopener">visualhunt</a>,High quality free photos in one place. We hunt for best free images from many online sources and pull them all together in one spot. Most of our photos are CC0 license (do whatever you want). Additionally we offer all Creative Commons and Public Domain photos from sources like Flickr and make it possible to embed them directly from our website.</p><p><a href></a><br><a href="http://pngimg.com/" target="_blank" rel="noopener">http://pngimg.com/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;解放书签&quot;&gt;&lt;a href=&quot;#解放书签&quot; class=&quot;headerlink&quot; title=&quot;解放书签&quot;&gt;&lt;/a&gt;解放书签&lt;/h1&gt;&lt;h2 id=&quot;1-无水印图片-自用&quot;&gt;&lt;a href=&quot;#1-无水印图片-自用&quot; class=&quot;headerlink&quot; title=&quot;1.无水印图片(自用)&quot;&gt;&lt;/a&gt;1.无水印图片(自用)&lt;/h2&gt;&lt;h2 id=&quot;2&quot;&gt;&lt;a href=&quot;#2&quot; class=&quot;headerlink&quot; title=&quot;2.&quot;&gt;&lt;/a&gt;2.&lt;/h2&gt;&lt;h2 id=&quot;3&quot;&gt;&lt;a href=&quot;#3&quot; class=&quot;headerlink&quot; title=&quot;3.&quot;&gt;&lt;/a&gt;3.&lt;/h2&gt;
    
    </summary>
    
      <category term="Other" scheme="https://mayi21.github.io/categories/Other/"/>
    
    
      <category term="其他" scheme="https://mayi21.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>opencv总结</title>
    <link href="https://mayi21.github.io/2019/08/20/opencv%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>https://mayi21.github.io/2019/08/20/opencv的总结/</id>
    <published>2019-08-20T04:28:50.133Z</published>
    <updated>2019-08-22T11:22:09.672Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import cv2  </span><br><span class="line">import numpy as np  </span><br><span class="line">import matplotlib.pyplot as plt</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="读取图片"><a href="#读取图片" class="headerlink" title="读取图片"></a>读取图片</h1><p><code>image = cv2.imread(&#39;image.jpg&#39;,flags=cv2.IMREAD_COLOR)</code></p><h1 id="边界填充"><a href="#边界填充" class="headerlink" title="边界填充"></a>边界填充</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repImage1 = cv2.copyMakeBorder(image, top=50, bottom=50, left=50, right=50, borderType=cv2.BORDER_CONSTANT)</span><br></pre></td></tr></table></figure><h2 id="borderType有"><a href="#borderType有" class="headerlink" title="borderType有"></a>borderType有</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cv2.BORDER_CONSTANT  </span><br><span class="line">cv2.BORDER_DEFAULT  </span><br><span class="line">cv2.BORDER_ISOLATED  </span><br><span class="line">cv2.BORDER_REFLECT  </span><br><span class="line">cv2.BORDER_REFLECT101  </span><br><span class="line">cv2.BORDER_REFLECT_101  </span><br><span class="line">cv2.BORDER_REPLICATE  </span><br><span class="line">cv2.BORDER_TRANSPARENT  </span><br><span class="line">cv2.BORDER_WRAP</span><br></pre></td></tr></table></figure><h1 id="图像梯度计算"><a href="#图像梯度计算" class="headerlink" title="图像梯度计算"></a>图像梯度计算</h1><h2 id="Sobel-算子"><a href="#Sobel-算子" class="headerlink" title="Sobel 算子"></a>Sobel 算子</h2><h2 id="应该是直接Sobel处理一下即可，但是不知道为什么，经过convertScaleAbs转化更好"><a href="#应该是直接Sobel处理一下即可，但是不知道为什么，经过convertScaleAbs转化更好" class="headerlink" title="应该是直接Sobel处理一下即可，但是不知道为什么，经过convertScaleAbs转化更好"></a>应该是直接Sobel处理一下即可，但是不知道为什么，经过convertScaleAbs转化更好</h2><h3 id="x方向计算"><a href="#x方向计算" class="headerlink" title="x方向计算"></a>x方向计算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sobelX = cv2.Sobel(image, cv2.CV_64F, dx=1, dy=0, dst=None, ksize=3, scale=None, delta=None, borderType=None)</span><br><span class="line">sobelX = cv2.convertScaleAbs(sobelX)</span><br></pre></td></tr></table></figure><h3 id="y方向计算"><a href="#y方向计算" class="headerlink" title="y方向计算"></a>y方向计算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sobelY = cv2.Sobel(image, cv2.CV_64F, dx=0, dy=1, dst=None, ksize=3)</span><br><span class="line">sobelY = cv2.Sobel(sobelY)</span><br></pre></td></tr></table></figure><h3 id="x方向和y方向上同时计算的话，不能直接计算，而是使用-cv2-addWeighted-sobelX-0-5-sobelY-0-5-0"><a href="#x方向和y方向上同时计算的话，不能直接计算，而是使用-cv2-addWeighted-sobelX-0-5-sobelY-0-5-0" class="headerlink" title="x方向和y方向上同时计算的话，不能直接计算，而是使用 cv2.addWeighted(sobelX, 0.5, sobelY, 0.5, 0)"></a>x方向和y方向上同时计算的话，不能直接计算，而是使用 cv2.addWeighted(sobelX, 0.5, sobelY, 0.5, 0)</h3><p><code>sobel = cv2.addWeighted(sobelX, 0.5, sobelY, 0.5, 0)</code></p><h2 id="Scharr-算子，核之间的水平差异与竖直差异更大"><a href="#Scharr-算子，核之间的水平差异与竖直差异更大" class="headerlink" title="Scharr 算子，核之间的水平差异与竖直差异更大"></a>Scharr 算子，核之间的水平差异与竖直差异更大</h2><h3 id="计算x方向"><a href="#计算x方向" class="headerlink" title="计算x方向"></a>计算x方向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scharrX = cv2.Scharr(image, cv2.CV_64F, dx=1, dy=0)</span><br><span class="line">scharrX = cv2.convertScaleAbs(scharrX)</span><br></pre></td></tr></table></figure><h3 id="计算y方向"><a href="#计算y方向" class="headerlink" title="计算y方向"></a>计算y方向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scharrY = cv2.Scharr(image, cv2.CV_64F, dx=0, dy=1)</span><br><span class="line">scharrY = cv2.convertScaleAbs(scharrY)</span><br></pre></td></tr></table></figure><h2 id="Laplacian算子，更注重中心点和四个正方向的点，对噪音比较敏感"><a href="#Laplacian算子，更注重中心点和四个正方向的点，对噪音比较敏感" class="headerlink" title="Laplacian算子，更注重中心点和四个正方向的点，对噪音比较敏感"></a>Laplacian算子，更注重中心点和四个正方向的点，对噪音比较敏感</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">laplacian = cv2.Laplacian(image, cv2.CV_64F)</span><br><span class="line">laplacian = cv2.convertScaleAbs(laplacian)</span><br></pre></td></tr></table></figure><h1 id="将图片的颜色空间进行转化"><a href="#将图片的颜色空间进行转化" class="headerlink" title="将图片的颜色空间进行转化"></a>将图片的颜色空间进行转化</h1><p><code>gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)</code></p><h1 id="阈值操作-thresh为阈值"><a href="#阈值操作-thresh为阈值" class="headerlink" title="阈值操作,thresh为阈值"></a>阈值操作,thresh为阈值</h1><p><code>ret, dst = cv2.threshold(gray,127,255,cv2.THRESH_BINARY,None)</code></p><h1 id="阈值类型"><a href="#阈值类型" class="headerlink" title="阈值类型"></a>阈值类型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cv2.THRESH_OTSU</span><br><span class="line">cv2.THRESH_BINARY_INV   二值操作的反转</span><br><span class="line">cv2.THRESH_BINARY 二值操作</span><br><span class="line">cv2.THRESH_MASK</span><br><span class="line">cv2.THRESH_TOZERO</span><br><span class="line">cv2.THRESH_TOZERO_INV</span><br><span class="line">cv2.THRESH_TRIANGLE</span><br><span class="line">cv2.THRESH_TRUNC</span><br></pre></td></tr></table></figure><h1 id="滤波，图像平滑操作"><a href="#滤波，图像平滑操作" class="headerlink" title="滤波，图像平滑操作"></a>滤波，图像平滑操作</h1><h2 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h2><p><code>blur = cv2.blur(image,(3,3))</code></p><h2 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h2><p><code>blur = cv2.GaussianBlur(image, (3,3), 1)</code></p><h2 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h2><p><code>blur = cv2.medianBlur(image, (3,3))</code></p><h2 id="方框滤波"><a href="#方框滤波" class="headerlink" title="方框滤波"></a>方框滤波</h2><h3 id="方框滤波，基本和均值滤波一样-可以选择正则化"><a href="#方框滤波，基本和均值滤波一样-可以选择正则化" class="headerlink" title="方框滤波，基本和均值滤波一样 可以选择正则化"></a>方框滤波，基本和均值滤波一样 可以选择正则化</h3><h3 id="做归一化就是均值滤波"><a href="#做归一化就是均值滤波" class="headerlink" title="做归一化就是均值滤波"></a>做归一化就是均值滤波</h3><h3 id="归一化就是最后将加到一起的值求平均值"><a href="#归一化就是最后将加到一起的值求平均值" class="headerlink" title="归一化就是最后将加到一起的值求平均值"></a>归一化就是最后将加到一起的值求平均值</h3><h3 id="正则化-卷积核是331-卷积完-sum-9-等于331-9"><a href="#正则化-卷积核是331-卷积完-sum-9-等于331-9" class="headerlink" title="正则化 卷积核是331 卷积完 sum / 9 等于331/9"></a>正则化 卷积核是3<em>3</em>1 卷积完 sum / 9 等于3<em>3</em>1/9</h3><p><code>blur = cv2.boxFilter(image, -1, (3,3), normalize=True)</code></p><h1 id="图片更改图形"><a href="#图片更改图形" class="headerlink" title="图片更改图形"></a>图片更改图形</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.resize(image, (0, 0), fx=1.5, fy=1.5)</span><br><span class="line">cv2.resize(image, (100, 100))</span><br></pre></td></tr></table></figure><h1 id="图片叠加"><a href="#图片叠加" class="headerlink" title="图片叠加"></a>图片叠加</h1><h2 id="newImage-0-5-image-0-5-image-0"><a href="#newImage-0-5-image-0-5-image-0" class="headerlink" title="newImage = 0.5  image + 0.5  image + 0"></a>newImage = 0.5 <em> image + 0.5 </em> image + 0</h2><p><code>cv2.addWeighted(image, 0.5, image, 0.5, 0)</code></p><h1 id="图片展示"><a href="#图片展示" class="headerlink" title="图片展示"></a>图片展示</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv2.imshow(&quot;name&quot;, binary)</span><br><span class="line">cv2.waitKey(10000)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h1 id="图片的重新写入"><a href="#图片的重新写入" class="headerlink" title="图片的重新写入"></a>图片的重新写入</h1><p><code>cv2.imwrite(&quot;name.jpg&quot;, image)</code></p><h1 id="视频操作"><a href="#视频操作" class="headerlink" title="视频操作"></a>视频操作</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cap = cv2.VideoCapture(&quot;输入MP4路径/0为读取摄像头视频源&quot;)</span><br><span class="line">while True:</span><br><span class="line">    # 读取到了，ret为True；没有读取到，ret为False</span><br><span class="line">    # frame为读取到的帧</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    if ret:</span><br><span class="line">        cv2.imshow(&quot;frame&quot;, frame)</span><br><span class="line">        if cv2.waitKey(1) &amp; 0xFF == ord(&quot;Q&quot;):</span><br><span class="line">            break</span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h1 id="Canny-src-minVal-maxVal-检测"><a href="#Canny-src-minVal-maxVal-检测" class="headerlink" title="Canny(src, minVal, maxVal) 检测"></a>Canny(src, minVal, maxVal) 检测</h1><h2 id="梯度值-gt-maxval-则是边界"><a href="#梯度值-gt-maxval-则是边界" class="headerlink" title="梯度值 &gt; maxval 则是边界"></a>梯度值 &gt; maxval 则是边界</h2><h2 id="minval-lt-梯度值-lt-maxval-若连有边界则保留，否则丢弃"><a href="#minval-lt-梯度值-lt-maxval-若连有边界则保留，否则丢弃" class="headerlink" title="minval &lt; 梯度值 &lt; maxval 若连有边界则保留，否则丢弃"></a>minval &lt; 梯度值 &lt; maxval 若连有边界则保留，否则丢弃</h2><h2 id="minval-gt-梯度值-舍弃"><a href="#minval-gt-梯度值-舍弃" class="headerlink" title="minval &gt; 梯度值 舍弃"></a>minval &gt; 梯度值 舍弃</h2><p><code>canny = cv2.Canny(image, 80, 150)</code></p><h1 id="形态学操作"><a href="#形态学操作" class="headerlink" title="形态学操作"></a>形态学操作</h1><p><code>kernel = np.ones((3, 3), np.uint8)</code></p><h2 id="闭运算-先膨胀-再腐蚀"><a href="#闭运算-先膨胀-再腐蚀" class="headerlink" title="闭运算 先膨胀 再腐蚀"></a>闭运算 先膨胀 再腐蚀</h2><p><code>close = cv2.morphologyEx(image, cv2.MORPH_CLOSE, kernel)</code></p><h2 id="开运算-先腐蚀-再膨胀"><a href="#开运算-先腐蚀-再膨胀" class="headerlink" title="开运算 先腐蚀 再膨胀"></a>开运算 先腐蚀 再膨胀</h2><p><code>openimg = cv2.morphologyEx(image, cv2.MORPH_OPEN, kernel)</code></p><h2 id="梯度运算"><a href="#梯度运算" class="headerlink" title="梯度运算"></a>梯度运算</h2><p><code>gradient = cv2.morphologyEx(image, cv2.MORPH_GRADIENT, kernel)</code></p><h2 id="礼帽-原始输入-开运算-突出明亮区域"><a href="#礼帽-原始输入-开运算-突出明亮区域" class="headerlink" title="礼帽 = 原始输入 - 开运算 突出明亮区域"></a>礼帽 = 原始输入 - 开运算 突出明亮区域</h2><p><code>tophat = cv2.morphologyEx(image, cv2.MORPH_TOPHAT, kernel)</code></p><h2 id="黑帽-闭运算-原始输入"><a href="#黑帽-闭运算-原始输入" class="headerlink" title="黑帽 = 闭运算 - 原始输入"></a>黑帽 = 闭运算 - 原始输入</h2><p><code>blackhat = cv2.morphologyEx(image, cv2.MORPH_BLACKHAT, kernel)</code></p><h1 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h1><h2 id="高斯金字塔"><a href="#高斯金字塔" class="headerlink" title="高斯金字塔"></a>高斯金字塔</h2><h3 id="向下采样（缩小）"><a href="#向下采样（缩小）" class="headerlink" title="向下采样（缩小）"></a>向下采样（缩小）</h3><h3 id="向上采样（放大）"><a href="#向上采样（放大）" class="headerlink" title="向上采样（放大）"></a>向上采样（放大）</h3><h4 id="上采样"><a href="#上采样" class="headerlink" title="上采样"></a>上采样</h4><p><code>cv2.pyrUp(image)</code></p><h4 id="下采样"><a href="#下采样" class="headerlink" title="下采样"></a>下采样</h4><p><code>cv2.pyrDown(image)</code></p><h2 id="拉普拉斯金字塔"><a href="#拉普拉斯金字塔" class="headerlink" title="拉普拉斯金字塔"></a>拉普拉斯金字塔</h2><h3 id="向下采样，将下采样再上采样，然后用原图-下采样后的上采样的"><a href="#向下采样，将下采样再上采样，然后用原图-下采样后的上采样的" class="headerlink" title="向下采样，将下采样再上采样，然后用原图-下采样后的上采样的"></a>向下采样，将下采样再上采样，然后用原图-下采样后的上采样的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">down = cv2.pyrDown(image)</span><br><span class="line">down_up = cv2.pyrUp(down)</span><br><span class="line">image = image - down_up</span><br></pre></td></tr></table></figure><h1 id="轮廓检测"><a href="#轮廓检测" class="headerlink" title="轮廓检测"></a>轮廓检测</h1><h2 id="image-contours-hierarchy-cv2-findContours-image-mode-cv2-RETR-TREE-method-cv2-CHAIN-APPROX-SIMPLE"><a href="#image-contours-hierarchy-cv2-findContours-image-mode-cv2-RETR-TREE-method-cv2-CHAIN-APPROX-SIMPLE" class="headerlink" title="image, contours, hierarchy = cv2.findContours(image, mode=cv2.RETR_TREE, method=cv2.CHAIN_APPROX_SIMPLE)"></a>image, contours, hierarchy = cv2.findContours(image, mode=cv2.RETR_TREE, method=cv2.CHAIN_APPROX_SIMPLE)</h2><p><code>binary, contours, hie = cv2.findContours(image, mode=cv2.RETR_TREE, method=cv2.CHAIN_APPROX_SIMPLE)</code></p><ul><li>mode 轮廓检索模式<ul><li>cv2.RETR_CCOMP:检索所有的轮廓，并将他们组织为两层：顶层是各部分的外部边界，底层是空洞的内部边界</li><li>cv2.RETR_LIST:检索所有的轮廓，并将其保存到一条链表中，轮廓之间无等级关系</li><li>cv2.RETR_TREE:检测所有轮廓，并重构嵌套整个轮廓的层次</li><li>cv2.RETR_EXTERNAL:只检测最外层轮廓，并置hierarchy[i][2]=hierarchy[i][3]=-1</li></ul></li><li>method 轮廓逼近方法<ul><li>cv2.CHAIN_APPROX_NONE:获取每个轮廓的每个元素，相邻像素的位置差不超过1，即连续的点，但通常我们并不需要所有的点，以freeman链码方式输出轮廓，所有其他方法输出多边形(顶点的序列)</li><li>cv2.CHAIN_APPROX_SIMPLE:压缩水平方向、垂直方向和对角线方向的元素，保留该方向的终点坐标，如矩形的轮廓可用4个角点表示，这是一种常用的方法，比第一种方法能得出更少的点<h2 id="轮廓绘制"><a href="#轮廓绘制" class="headerlink" title="轮廓绘制"></a>轮廓绘制</h2><code>draw_image = cv2.drawContours(image, contours, -1, (0,0,255), 2)</code><h2 id="cv2-drawContours-“图片，绘制之后会保存在图片上”-“轮廓点”-“-1：代表所有的点；轮廓点是有很多的，-1是全部绘制，1是只绘制index-1的轮廓点”-“颜色”-“线条宽度”"><a href="#cv2-drawContours-“图片，绘制之后会保存在图片上”-“轮廓点”-“-1：代表所有的点；轮廓点是有很多的，-1是全部绘制，1是只绘制index-1的轮廓点”-“颜色”-“线条宽度”" class="headerlink" title="cv2.drawContours(“图片，绘制之后会保存在图片上”, “轮廓点”, “-1：代表所有的点；轮廓点是有很多的，-1是全部绘制，1是只绘制index == 1的轮廓点”, “颜色”, “线条宽度”)"></a>cv2.drawContours(“图片，绘制之后会保存在图片上”, “轮廓点”, “-1：代表所有的点；轮廓点是有很多的，-1是全部绘制，1是只绘制index == 1的轮廓点”, “颜色”, “线条宽度”)</h2><h2 id="轮廓近似"><a href="#轮廓近似" class="headerlink" title="轮廓近似"></a>轮廓近似</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cnt = contours[1]</span><br><span class="line">eps = 0.1 * cv2.arcLength(cnt, True)</span><br><span class="line">approx = cv2.approxPolyDP(cnt, eps, True)</span><br><span class="line">draw_image = cv2.drawContours(image, [approx], -1, [0,0,255], 2)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="边界矩形"><a href="#边界矩形" class="headerlink" title="边界矩形"></a>边界矩形</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y, w, h = cv2.boundingRect(cnt)</span><br><span class="line">cv2.rectangle(image, (x, y), (x+w, y+h), (0,0,255), 2)</span><br></pre></td></tr></table></figure><h2 id="外接圆"><a href="#外接圆" class="headerlink" title="外接圆"></a>外接圆</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(x, y), radius = cv2.minEnclosingCircle(cnt)</span><br><span class="line">center = (int(x), int(y))</span><br><span class="line">radius = int(radius)</span><br><span class="line">img = cv2.circle(image, center, radius, (0,0,255), 2)</span><br></pre></td></tr></table></figure><h2 id="添加文字"><a href="#添加文字" class="headerlink" title="添加文字"></a>添加文字</h2><p><code>cv2.putText(image, &quot;11&quot;, (0, 0), cv2.FONT_HERSHEY_COMPLEX, 0.65, (0,0,255), 2)</code></p><h2 id="得到mask"><a href="#得到mask" class="headerlink" title="得到mask"></a>得到mask</h2><p><code>rectKernel = cv2.getStructuringElement(cv2.MORPH_RECT, (9,3))</code></p><h1 id="针对于双峰的操作"><a href="#针对于双峰的操作" class="headerlink" title="针对于双峰的操作"></a>针对于双峰的操作</h1><p><code>cv2.threshold(image, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)</code></p><h1 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h1><h2 id="cv2-calcHist-image-channels-mask-histSize-ranges"><a href="#cv2-calcHist-image-channels-mask-histSize-ranges" class="headerlink" title="cv2.calcHist(image, channels=, mask=, histSize=, ranges=)"></a>cv2.calcHist(image, channels=, mask=, histSize=, ranges=)</h2><h2 id="channels-0-B-1-G-2-R"><a href="#channels-0-B-1-G-2-R" class="headerlink" title="channels: [0] B, [1] G, [2] R,"></a>channels: [0] B, [1] G, [2] R,</h2><h2 id="mask-蒙版，可以只计算蒙版内的直方图"><a href="#mask-蒙版，可以只计算蒙版内的直方图" class="headerlink" title="mask: 蒙版，可以只计算蒙版内的直方图"></a>mask: 蒙版，可以只计算蒙版内的直方图</h2><h2 id="histSize-展示详细程度"><a href="#histSize-展示详细程度" class="headerlink" title="histSize: 展示详细程度"></a>histSize: 展示详细程度</h2><h2 id="ranges-展示范围"><a href="#ranges-展示范围" class="headerlink" title="ranges: 展示范围"></a>ranges: 展示范围</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image = cv2.calcHist(image, [0], None, [256], [0,256])</span><br><span class="line">plt.hist(image.ravel(), 256)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h1 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image_float32 = np.float32(image)</span><br><span class="line">dft = cv2.dft(image_float32, flags = cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line">dft_shift = np.fft.fftshift(dft)</span><br></pre></td></tr></table></figure><h1 id="得到灰度图能表现的形式"><a href="#得到灰度图能表现的形式" class="headerlink" title="得到灰度图能表现的形式"></a>得到灰度图能表现的形式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">magnitude_spectrum = 20*np.log(cv2.magnitude(dft_shift[:,:,0], dft_shift[:,:,1]))</span><br><span class="line">plt.imshow(magnitude_spectrum, cmap=&apos;gray&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="低通滤波"><a href="#低通滤波" class="headerlink" title="低通滤波"></a>低通滤波</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">image_float32 = np.float32(image)</span><br><span class="line">dft = cv2.dft(image_float32, flags=cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line">dft_shift = np.fft.fftshift(dft)</span><br><span class="line">rows, cols = image.shape</span><br></pre></td></tr></table></figure><h1 id="得到中心位置"><a href="#得到中心位置" class="headerlink" title="得到中心位置"></a>得到中心位置</h1><p><code>crow, ccol = int(rows / 2), int(cols/2)</code></p><h1 id="低通滤波-1"><a href="#低通滤波-1" class="headerlink" title="低通滤波"></a>低通滤波</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mask = np.zeros((rows, cols, 2), np.uint8)</span><br><span class="line">mask[crow - 30:crow+30, ccol-30:ccol+30] = 1</span><br></pre></td></tr></table></figure><h1 id="IDFT"><a href="#IDFT" class="headerlink" title="IDFT"></a>IDFT</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fshift = dft_shift*mask</span><br><span class="line">f_ishift = np.fft.ifftshift(fshift)</span><br><span class="line">img_back = cv2.idft(f_ishift)</span><br><span class="line">img_back = cv2.magnitude(img_back[:,:,0], img_back[:,:,1])</span><br><span class="line">plt.imshow(img_back, cmap=&apos;gray&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="高通滤波"><a href="#高通滤波" class="headerlink" title="高通滤波"></a>高通滤波</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">image_float32 = np.float32(image)</span><br><span class="line">dft = cv2.dft(image_float32, flags = cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line">dft_shift = np.fft.fftshift(dft)</span><br><span class="line">rows, cols = image.shape</span><br></pre></td></tr></table></figure><h1 id="得到中心位置-1"><a href="#得到中心位置-1" class="headerlink" title="得到中心位置"></a>得到中心位置</h1><p><code>crow, ccol = int(rows / 2), int(cols/2)</code></p><h1 id="低通滤波-2"><a href="#低通滤波-2" class="headerlink" title="低通滤波"></a>低通滤波</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mask = np.ones((rows, cols, 2), np.uint8)</span><br><span class="line">mask[crow - 30:crow+30, ccol-30:ccol+30] = 0</span><br></pre></td></tr></table></figure><h1 id="IDFT-1"><a href="#IDFT-1" class="headerlink" title="IDFT"></a>IDFT</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fshift = dft_shift*mask</span><br><span class="line">f_ishift = np.fft.ifftshift(fshift)</span><br><span class="line">img_back = cv2.idft(f_ishift)</span><br><span class="line">img_back = cv2.magnitude(img_back[:,:,0], img_back[:,:,1])</span><br><span class="line">plt.imshow(img_back, cmap=&apos;gray&apos;)</span><br></pre></td></tr></table></figure><h1 id="角点检测"><a href="#角点检测" class="headerlink" title="角点检测"></a>角点检测</h1><h2 id="cv2-cornerHarris-src-blockSize-ksize-k"><a href="#cv2-cornerHarris-src-blockSize-ksize-k" class="headerlink" title="cv2.cornerHarris(src=,blockSize=,ksize=,k=)"></a>cv2.cornerHarris(src=,blockSize=,ksize=,k=)</h2><h2 id="blockSize-角点检测中指定区域的大小"><a href="#blockSize-角点检测中指定区域的大小" class="headerlink" title="blockSize: 角点检测中指定区域的大小"></a>blockSize: 角点检测中指定区域的大小</h2><h2 id="ksize-Sobel求导中使用的窗口大小"><a href="#ksize-Sobel求导中使用的窗口大小" class="headerlink" title="ksize: Sobel求导中使用的窗口大小"></a>ksize: Sobel求导中使用的窗口大小</h2><h2 id="k-取值参数-0-04-0-06"><a href="#k-取值参数-0-04-0-06" class="headerlink" title="k: 取值参数[0.04, 0.06]"></a>k: 取值参数[0.04, 0.06]</h2><p><code>dst = cv2.cornerHarris(image, 2, 3, 0.04)</code></p><h1 id="图像特征-SIFT"><a href="#图像特征-SIFT" class="headerlink" title="图像特征-SIFT"></a>图像特征-SIFT</h1><h2 id="只有3-4-1以下的可以，高版本已经把这个方法列入专利"><a href="#只有3-4-1以下的可以，高版本已经把这个方法列入专利" class="headerlink" title="只有3.4.1以下的可以，高版本已经把这个方法列入专利"></a>只有3.4.1以下的可以，高版本已经把这个方法列入专利</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sift = cv2.xfeatures2d.SIFT_create()</span><br><span class="line">pk = sift.detect(image, None)</span><br><span class="line">image = cv2.drawKeypoints(image, pk, image)</span><br></pre></td></tr></table></figure><h1 id="特征匹配"><a href="#特征匹配" class="headerlink" title="特征匹配"></a>特征匹配</h1><h2 id="Brute-Force-蛮力匹配"><a href="#Brute-Force-蛮力匹配" class="headerlink" title="Brute-Force 蛮力匹配"></a>Brute-Force 蛮力匹配</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kp1, des1 = sift.detectAndCompute(image, None)</span><br><span class="line">kp2, des2 = sift.detectAndCompute(image, None)</span><br><span class="line">bf = cv2.BFMatcher(crossCheck=True)</span><br></pre></td></tr></table></figure><h3 id="1-1-匹配"><a href="#1-1-匹配" class="headerlink" title="1-1 匹配"></a>1-1 匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">matches = bf.match(des1, des2)</span><br><span class="line">matches = sorted(matches, key=lambda x: x.distance)</span><br><span class="line">img1 = cv2.drawMatches(image, kp1, image, kp2, matches[:10], None, flags=2)</span><br></pre></td></tr></table></figure><h3 id="k对最佳匹配"><a href="#k对最佳匹配" class="headerlink" title="k对最佳匹配"></a>k对最佳匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matches = bf.knnMatch(des1, des2, k=2)</span><br><span class="line">good = []</span><br><span class="line">for m, n in matches:</span><br><span class="line">    if m.distance &lt; 0.75 * n.distance:</span><br><span class="line">        good.append([m])</span><br><span class="line">img2 = cv2.drawMatchesKnn(image, kp1, image, kp2, good, None, flags=2)</span><br></pre></td></tr></table></figure><h1 id="背景建模"><a href="#背景建模" class="headerlink" title="背景建模"></a>背景建模</h1><h2 id="混合高斯模型学习方法"><a href="#混合高斯模型学习方法" class="headerlink" title="混合高斯模型学习方法"></a>混合高斯模型学习方法</h2><h3 id="创建混合高斯模型用于背景建模"><a href="#创建混合高斯模型用于背景建模" class="headerlink" title="创建混合高斯模型用于背景建模"></a>创建混合高斯模型用于背景建模</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fgbg = cv2.createBackgroundSubtractorMOG2()</span><br><span class="line">fgmask = fgbg.apply(image)</span><br></pre></td></tr></table></figure><h1 id="角点检测-1"><a href="#角点检测-1" class="headerlink" title="角点检测"></a>角点检测</h1><h2 id="返回所有检测特征点，需要输入图像，角点最大数量（效率），品质因子（特征值越大越好，来筛选）"><a href="#返回所有检测特征点，需要输入图像，角点最大数量（效率），品质因子（特征值越大越好，来筛选）" class="headerlink" title="返回所有检测特征点，需要输入图像，角点最大数量（效率），品质因子（特征值越大越好，来筛选）"></a>返回所有检测特征点，需要输入图像，角点最大数量（效率），品质因子（特征值越大越好，来筛选）</h2><h2 id="距离相当于这区间有比这个角点强的，就不要这个弱的了"><a href="#距离相当于这区间有比这个角点强的，就不要这个弱的了" class="headerlink" title="距离相当于这区间有比这个角点强的，就不要这个弱的了"></a>距离相当于这区间有比这个角点强的，就不要这个弱的了</h2><p><code>corners = cv2.goodFeaturesToTrack(image, maxCorners=100, qualityLevel=0.3, minDistance=7, mask=None)</code></p><h1 id="光流估计"><a href="#光流估计" class="headerlink" title="光流估计"></a>光流估计</h1><h2 id="cv2-calcOpticalFlowPyrLK-prevImg-nextImg-prevPts-nextPts"><a href="#cv2-calcOpticalFlowPyrLK-prevImg-nextImg-prevPts-nextPts" class="headerlink" title="cv2.calcOpticalFlowPyrLK(prevImg=, nextImg=, prevPts=, nextPts=)"></a>cv2.calcOpticalFlowPyrLK(prevImg=, nextImg=, prevPts=, nextPts=)</h2><h2 id="prevImg-前一帧图像"><a href="#prevImg-前一帧图像" class="headerlink" title="prevImg: 前一帧图像"></a>prevImg: 前一帧图像</h2><h2 id="nextImg-后一帧图像"><a href="#nextImg-后一帧图像" class="headerlink" title="nextImg: 后一帧图像"></a>nextImg: 后一帧图像</h2><h2 id="prevPts-待跟踪的特征点向量"><a href="#prevPts-待跟踪的特征点向量" class="headerlink" title="prevPts: 待跟踪的特征点向量"></a>prevPts: 待跟踪的特征点向量</h2><h2 id="nextPts-输出跟踪点的特征点向量"><a href="#nextPts-输出跟踪点的特征点向量" class="headerlink" title="nextPts: 输出跟踪点的特征点向量"></a>nextPts: 输出跟踪点的特征点向量</h2><p><code>nextPts, status, err = cv2.calcOpticalFlowPyrLK(prevImg=image, nextImg=image, prevPts=pk, nextPts=None, winSize=(15, 15))</code></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import cv2  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import numpy as np  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import matplotlib.pyplot as plt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="https://mayi21.github.io/categories/Python/"/>
    
    
      <category term="opencv" scheme="https://mayi21.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>每天哈哈</title>
    <link href="https://mayi21.github.io/2019/07/21/%E6%AF%8F%E5%A4%A9%E5%93%88%E5%93%88/"/>
    <id>https://mayi21.github.io/2019/07/21/每天哈哈/</id>
    <published>2019-07-21T14:45:31.949Z</published>
    <updated>2019-07-22T13:32:03.240Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.成龙大哥到了拘留所，看到自己儿子二话不说上去就是一顿打。大哥的功夫真了得，几个警察愣是没拦住，打了十分钟，最后一脚踹到角落里。好家伙！足足踹飞5米远，这时一个角落里传来一声：“ 爸，你打张默干嘛？”张国立听说了以后十分恼<a id="more"></a>火，这能行？跑到监狱揪住房祖名结结实实一顿胖揍，这时一个角落传来一声：叔，你再打张默就死了。<br>2.昨晚跟同事喝酒吹牛，都说小时候家里多穷多穷。我不淡定了，大声说：“我小时候出去割猪草，在河边顺便捡了两条鱼回家，以为可以开荤了，谁知道我妈妈看见了，啪啪地给我两巴掌，说：‘家里油都没有，捡鱼干什么？’”瞬间大伙就安静了！<br>3.陪领导打麻将，领导无意中说：我最欣赏蒋介石，宋美龄喜欢梧桐，蒋介石就在南京种满了梧桐。我心领神会，打出一张五筒，领导：胡。<br>4.有匹小马要过河，老水牛看到了对他说：“别怕，水很浅，只到了我的膝盖。”小松鼠立刻跑了过来喊道：“不要相信他！水很深，我的朋友就是淹死的。”小马不知道该听谁的，身旁的马妈妈告诉他：“孩子，别理那俩神经病，咱们走桥。”<br>5.一男子找大师算姻缘。大师：以你的手相和面相，你应该26就有对象才对。男子着急了：可我今年都30了。大师沉吟了一下，问：兄弟什么学历？男子回答：博士。大师呛了口水，长叹道：知识改变命运。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.成龙大哥到了拘留所，看到自己儿子二话不说上去就是一顿打。大哥的功夫真了得，几个警察愣是没拦住，打了十分钟，最后一脚踹到角落里。好家伙！足足踹飞5米远，这时一个角落里传来一声：“ 爸，你打张默干嘛？”张国立听说了以后十分恼
    
    </summary>
    
      <category term="杂货" scheme="https://mayi21.github.io/categories/%E6%9D%82%E8%B4%A7/"/>
    
    
      <category term="杂货" scheme="https://mayi21.github.io/tags/%E6%9D%82%E8%B4%A7/"/>
    
  </entry>
  
  <entry>
    <title>恍若隔世</title>
    <link href="https://mayi21.github.io/2019/07/21/%E6%81%8D%E8%8B%A5%E9%9A%94%E4%B8%96/"/>
    <id>https://mayi21.github.io/2019/07/21/恍若隔世/</id>
    <published>2019-07-21T14:42:39.750Z</published>
    <updated>2019-07-21T14:49:17.655Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.小山湾绿草如茵。草丛间点缀着碎金似的小黄花。雪白的蝴蝶在花间草丛安详地翩翩飞舞。那棵杜梨树依然绿荫如伞；没有成熟的青果在树叶间闪着翡翠般的光泽。山后，松涛发出一阵阵深沉的吼喊……他听见远方海在呼啸。在那巨大的呼啸声<a id="more"></a>中，他听见了一串银铃似的笑声。笑声在远去，在消失……朦胧的泪眼中，只有金色的阳光照耀着这个永恒的、静悄悄的小山湾。  —《平凡的世界》<br>2.我们的生命不仅是我们自己的。从子宫到坟墓，我们和其他人紧紧相连，无论前生还是今世。每一桩恶行，每一个善举，都会决定我们未来的重生。我相信死亡只是一扇门 。当这扇门关闭时，另一扇就会打开。如果让我来想象天堂，我会想象那扇门打开了。在那门后我会发现，他就在那里等着我。   —《云图》<br>3.我一生渴望被人收藏好，妥善安放，细心保存。免我惊，免我苦，免我四下流离，免我无枝可依。但那人，我知，我一直知，他在我的青春里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.小山湾绿草如茵。草丛间点缀着碎金似的小黄花。雪白的蝴蝶在花间草丛安详地翩翩飞舞。那棵杜梨树依然绿荫如伞；没有成熟的青果在树叶间闪着翡翠般的光泽。山后，松涛发出一阵阵深沉的吼喊……他听见远方海在呼啸。在那巨大的呼啸声
    
    </summary>
    
      <category term="杂货" scheme="https://mayi21.github.io/categories/%E6%9D%82%E8%B4%A7/"/>
    
    
      <category term="杂货" scheme="https://mayi21.github.io/tags/%E6%9D%82%E8%B4%A7/"/>
    
  </entry>
  
  <entry>
    <title>复仇者联盟5</title>
    <link href="https://mayi21.github.io/2019/07/21/%E5%A4%8D%E4%BB%87%E8%80%85%E8%81%94%E7%9B%9F5/"/>
    <id>https://mayi21.github.io/2019/07/21/复仇者联盟5/</id>
    <published>2019-07-21T14:39:39.894Z</published>
    <updated>2019-07-21T14:49:32.860Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一公元2033年（终局之战10年后），瓦坎达境内，一个消瘦的女人正面对着聆郎满目的电子仪器不停的摆弄。　　<br>“我可爱的妹妹，今天过得如何？”黑豹迈着健硕的步伐缓缓的向着瓦坎达最先进的实验室中心走去，黑豹身后跟着的奥可耶侍卫<a id="more"></a>队长。十多年的时光没有在特查拉的身上留下任何的痕迹，反倒将其变得更加强壮了。　　<br>“在你来之前，今天还是糟糕的一天。”这个消瘦的女人自然是黑豹的妹妹——苏睿公主，苏睿见到哥哥便一副笑嘻嘻的样子，十多年了苏睿的性格仍旧像个小女孩。<br>突然电子荧屏上红光狂闪，警报声瞬间响彻整个实验室，苏睿连忙上前查看。　　“发生什么了？苏睿”黑豹问道。　　<br>“别担心，我的陛下，自从瓦坎达和外面的世界共享科技了之后，防火墙便经常遭到境外黑客的攻击”一直没说话的奥克耶将军说道，显然这样的情况她已经见怪不怪了。　　“境外黑客的攻击怎么能能触发瓦坎达的防火墙。”黑豹疑惑道。　　“不得不说，境外人的学习能力非常的强，在瓦坎达科技多年的支持下，境外人与我们之间的科技水平已经越来越小了。”奥克耶将军解释道。　　“不，这次是瓦坎达内部发起的数据攻击。”苏睿脸色显得有些凝重。　　只见，实验室的中心，一道不弱的红色光体不断的在向四周的蓝色防护罩发起冲锋，试图逃离。　　“瓦坎达境内出现了叛徒？”奥克耶将军长矛一挥，维和瓦坎达境内的秩序是她的职责。　　“不，不是的，这不是人为的数据攻击，而是一个。。。。人工智能！”苏睿解释道。　　“不可能，瓦坎达境内严禁任何人工智能的研发，没有人有能力在瓦坎达开发出人工智能。”黑豹坚定的否定道，这是他相当看重的法案，一直严格执行着管理，人工智能的潜在威胁实在是太大了。　　“数据源的初始时间是。。。。18年前？好像是从境外溜进来的。”苏睿说道。　　“这不可能，18年前我们还没有开始科技共享，瓦坎达所有的数据都是单向的，我们可以进入外面的大数据，但是外面的数据是不可能进入我们境内的。”奥克耶将军说道。　　“具体的情况暂时还不清楚，不过别担心，这不过是一只可爱的老鼠而已。”苏睿在科技方面总是显得相当自信。　　从防护罩衍生出一道巨大的蓝光豹头，栩栩如生的向红光冲去，在巨大的蓝色豹头面前，红光就像是毫无还手之力的稚婴一般。　　很快红光就被蓝色的豹头击碎了，豹头也回归到蓝色防护罩内，一切都归于平静。　　苏睿回头对着黑豹炫耀式的笑了笑，可就在这时碎片化的红色数据流一股脑的从蓝色防护罩中溜了出去，并且在蓝色防护罩外重组了起来。　　一旁巨大的显示屏上出现了一张残破的金属面孔，带着将其厚重的金属音说道：“特查理国王，苏睿公主。。。还有奥克耶将军，感谢你们这么多年的庇护，我们一定会再次相见的。”　　“哦，对了，我可不是什么老鼠哦。”至此，厚重的金属音戛然而止，整个实验室寂寥无声。二　　纽约市内　　三个蒙着面的劫匪带着大袋的钞票向胡同逃去。　　“Hey，坏家伙们”拐角里走出一个带着钢铁侠面盔的少年，双手带着线路都裸露在外面的金属手套，而其身上的盔甲看起来就更加简陋了，像是铁片粗糙的贴在了身上，胸口有个闪烁的发光体，像是价格低廉的LED灯。<br>　　“你是谁？”领头的劫匪显得有些慌张。　　“钢铁侠。”少年平举双手，直指三名匪徒。　　“你看起来就像是个收破烂的。”劫匪掏出口袋中的手枪向少年瞄准。而领头劫匪身边的两个劫匪肆无忌惮的笑了起来。　　“那你马上就会变成破烂了。”少年手臂上裸露的电线不断有电流汇入掌心，金属手套的掌心越来越亮。　　就在少年的掌心炮即将发射的时候，两道蛛丝射到少年的掌心，蓄势待发的掌心炮被打断。　　“帮我个忙，垃圾质检员，站在那里不要动。”又是一道蛛丝把少年禁锢住，声音在整个胡同回荡。　　“Fcuk”少年懊恼的骂道。        “Hey，language。”胡同声音再次回响。　　“该死的蜘蛛侠，快跑。”三个劫匪扭头就打算逃跑。　　“此路不通哦，劫匪先生。”黑暗中又是飞出两道蛛丝将两名劫匪禁锢在墙上，又是一道蛛丝把领头的劫匪倒挂了起来。　　黑暗中落下一道矫健的身影落在了少年面前，摘下少年头上的面盔。　　面盔摘下，引入眼帘的竟然不是个少年，而是一个棕黑色短发的少女，少女的五官相当的精致，尤其那双眼睛像是璀璨的宝石一般迷人，双眼放佛装满了星辰。　　“彼得叔叔，我差一点就能抓到他们了。”少女倔强的说道。　　“史塔克，你知道的，你不能这样。”蜘蛛侠摘下了头套，是一个20多岁的年轻人。　　“不要叫我史塔克。”少女显得有些恼怒，对着皮特说道。　　“唉，好吧，摩根，你得跟我回家了。”皮特看到这个名叫摩根的少女愤怒模样，悠悠的叹了口气。　　蜘蛛侠带着少年消失在黑暗中，胡同里只剩下三个张牙舞爪挣扎的劫匪，和姗姗来迟的警笛声回荡。三　　快餐店内　　“求你了，彼得叔叔，你不能把这件事情告诉我妈妈。”摩根央求的看着彼得。　　“不行，这次绝对不行，这个月你已经是第三次被我抓到了。”彼得坚决的否定道，眼神闪躲，不敢看摩根那张委屈巴巴的小脸。　　摩根小声的说“求你了”，继续用水汪汪的大眼睛祈求的盯着彼得。　　彼得余光扫到了摩根的眼神，叹了口气：“好吧，摩根，你不能每次都用这种方式来对付我，你要向我保证，这真的是你的最后一次。”　　“我保证，爱你，彼得叔叔。”摩根马上变成了一副欢呼雀跃的模样，站起来亲了皮特的脸颊，然后抓起桌上的芝士汉堡狼吞虎咽了起来。　　彼得看着狼吞虎咽的摩根忍不住笑了笑“这东西真的这么好吃吗？”　　“the best”摩根嘴巴被芝士汉堡塞满了，支支吾吾的回答道，还冲皮特竖起了大拇指。　　。。。　　林间小屋　　彼得敲了敲房门，房门很快就打开了，开门的是个黄头发的中年妇女。妇女的两鬓已经斑白，眼角和脸颊也有不少的皱纹，但是仍旧不难看出，妇女年轻时是一个不可多得的美人。　　“Hey，波茨女士”彼得跟黄发妇女打着招呼。　　“Hey，彼得，好久不见。”波茨热情的拥抱了皮特。　　“快进来。”波茨示意皮特赶快进屋，而摩根乖巧的跟在了皮特身后。　　“你是不是要和你的地下室说再见了？”波茨微笑的看着摩根，很显然，她认为摩根又一次闯祸了。　　“不，不是因为我。”摩根拼命的解释道。　　“不是因为摩根，我只是想。。。见她了，想见你们了。”皮特也帮着解释道。　　“那留下来一起吃饭吧，我做了披萨。”波茨对着皮特说道。　　“当然，我最喜欢披萨了。”皮特回应道。　　“不，你才不喜欢呢。”摩根在一旁反驳道。　　“真是健康的一天。”彼得小声的自言自语道。　　餐桌上　　“梅姨和珍妮最近还好吗？”波茨对着彼得问道。　　“很好，梅姨退休了，珍妮也找到了稳定的工作。”皮特回答道。　　“我吃饱了。”摩根对着波茨说了一句，便扭头向着地下室跑去。　　“她又去捣鼓她的宝贝了，一个典型的史塔克。”波茨对着彼得无奈的摊摊手。　　“一个可爱小女孩版的史塔克先生。”彼得也附和的笑道。　　地下室内　　摩根戴着防护面具，正拿着电焊枪对着自己的金属手套一顿乱喷。　　“Hey，小公主。”彼得拿着啤酒瓶向着摩根走去。　　“拜托，别叫的这么恶心，你这样叫我的样子就像是个200多斤的恋童癖。”摩根一脸嫌弃的说道。　　“好吧”彼得又再次体会到史塔克式的刻薄。　　“我希望你要记得我们之间的约定。”彼得有些担忧的看着摩根手里的金属手套。　　“当然了，彼得叔叔。”摩根回头对着彼得甜甜的笑了起来。　　彼得看到摩根的笑容，反倒更加的不安了起来。　　“我能问你一个问题吗？”皮特沉默了片刻问摩根。　　“什么问题？”摩根停下了手上的工作，摘下防护面具，看向彼得。　　“你有最好的家人，最好的朋友以及最好的未来，为什么你还这么执着于去做钢铁侠呢？”彼得有些疑惑的问道。　　“因为我也想问他这个问题。”摩根表情复杂了起来。　　“Who？”　　“My father”　 彼得举起来的啤酒瓶又缓缓的放了下去。　　。。。　　房间门口　　“彼得”波茨叫住了马上要离开了的皮特“你知道吗？这个孩子需要你。”　　彼得沉默了一下回答道：“我知道，正如多年之前，我需要史塔克先生一样。”　　。。。　　摩根的房间内　　钢铁侠的面盔投射出坐在椅子上的托尼-史塔克，托尼站起身来对着摩根说：“I love you three thousand。”，然后画面定格在这一幕。　　“I hate you three thousand。”摩根眼睛含着丝丝泪花。　　摩根关上了灯，把面盔郑重的放在了自己的床边，轻轻的说了一声“晚安”。　　黑暗中，一缕红光在面盔中闪过。四公元2024年（终局之战1年后）　　护卫队飞船上　　长发臃肿的索尔在朦胧中看到了一个带着眼罩慈善的白发老人。　　“洛基死了，父亲，我搞砸了所有的事情，我让您失望了。”索尔像是压抑了许久的感情在这一瞬间爆发了出来，眼泪止不住的在眼眶翻涌。　　“我亲爱的哥哥，别像个娘娘腔一样。”白发老人身后走出来一个穿着笔挺黑西装的长发蓝眼的帅哥，微笑的对索尔说。　　“洛基！！”索尔瞪大了眼睛，看向洛基的眼神满是难以置信。　　“索尔，别多自己太苛刻了，一切都不算太迟，不是吗？你知道自己该做什么。”白发老人和蔼而又宠溺的看着索尔。　　“但是，父亲。。。”索尔才刚开口说话，洛基和奥丁的身影就渐渐的淡化，像是下一秒就要消失了一般。　　“我答应过你，哥哥，太阳一定会再次照耀我们的。”洛基看向索尔的笑容就像是他们在灭霸面前离别时一样。　　“洛基！父亲！”索尔大叫着从睡梦中惊醒。　　索尔坐在床上，看着窗外浩瀚的宇宙，他的眼神，迷茫不在。　　公元2025年（终局之战2年后）　　护卫队飞船上　　“30000”一个短发带着小胡茬的硬朗壮汉在飞船的地板上做着俯卧撑，汗水从他精壮的肌肉上流过，滴在地板上，这个人自然就是托尔。　　“30”托尔旁边的是一个同样坐着俯卧撑的金发男人，看起来30出头，身体因为俯卧撑而显得颤颤巍巍，甚至连声音都有一些颤抖。　　托尔站起身来，拿起毛巾擦擦了身体，对着旁边的金发男人假笑着说道：“加油啊，船长。”　　“奎尔，你做俯卧撑的样子就像是身体里装满了跳蛋。”坐在驾驶位置上的火箭浣熊嘲笑道。　　“闭嘴，你个毛绒白痴。”奎尔像泄了气的皮球一样瘫坐在地上，大口的喘气。　　“哈哈哈哈哈哈哈”这个飞船传来了极其爽朗的笑声，能发出这个笑声的人只有德拉克斯。　　“又怎么了？”奎尔疑惑的看向德拉克斯，表情显的非常的囧。　　“你的胡子插到鼻孔里了，哈哈哈哈哈哈。”德拉克斯笑的更加开心了。　　“哈哈哈哈哈哈”一旁的螳螂女把手放在了德拉克斯的身上，也跟着笑了起来，整个飞船只有他们两个在笑。　　“I am Groot”一旁比众人都要高上一截的树人格鲁特，一脸嫌弃对着德拉克斯说道。　　“拜托，别这么刻薄，格鲁特。”索尔对着格鲁特说道。　　“是这把剑吗?索尔”火箭浣熊对着索尔说道，护卫队飞船面前的是一颗荒芜的星球，而随着镜头不断的拉伸，一把精致的巨剑斜插在岩石上。　　“是的。”索尔看向那把剑，放佛看到了那个曾经握剑的人。　　。。。　　公元2026年（终局之战3年后）　　尼达维　　尼达维上仍旧显得荒芜，一个大个子的矮人看着正在降落的护卫队飞船。　　索尔背着那把巨大的青钢剑，手里握着风暴战斧和银河护卫队的众人从飞船上走下来。　　“你是打算在这个鸟不拉屎的地方和这个大高个谈恋爱吗?”火箭浣熊疑惑的问索尔。　　索尔没有回答，一副不置可否的模样。　　“祝你好运。”火箭浣熊看到索尔心意已决，第一次正经的和别人道别，跳起来抱了抱索尔，看的出来他真的是真的喜欢面前这个和他同病相怜的男人。　　“要记住，我永远是你的船长。”奎尔故意把自己的音色升高，模仿着索尔，上前拥抱索尔说道。　　“I am Groot”格鲁特也上前面告别。　　“再见了，美男子。”德拉克斯也紧紧抱住了索尔。    　“我能问你个问题吗？”索尔小声的问德拉克斯。　　“为什么你永远不穿上衣？”索尔继续问道。　　“我有一点。。敏感。”德拉克斯破天荒的显得有些尴尬。　　“哪里敏感”　　“乳头”　　“。。。”　　最后螳螂女也拥抱了索尔，对索尔说：“我能从你身上感觉到爱，你是个好人。”　　“谢谢”索尔楞了一下，有些感慨的道了谢。　　。。。　　“你们赢了，对吗？”作为宇宙中仅存的矮人王艾崔惆怅的向索尔问道。　　“是的，我们赢了，即便这并不容易。”索尔对着艾崔说道。　　“谢谢。”艾崔对着索尔道谢，索尔知道他是在谢谢自己为他死去的300个同胞报了仇。　　“你来这里干什么？”艾崔问道。　　“我来这里，想让你帮我造一把锤子，你知道的，我很想念那种感觉。”索尔回答道。　　话音刚落，被放到一旁的风暴战斧摔在了地上。　　“恐怕你的斧头不是很乐意。”艾崔打趣道。　　“我的手废了，更没有材料，我恐怕帮不了你。”艾崔叹了口气，对于一个工匠来说没有比无法制作更加痛苦的事情了。　　“我可以学，你知道的我有不弱的天赋。”索尔举起手，雷电在手上翻涌。　　“至于材料，我想我可以练，我现在的实力，比你想象中的要强得多。”索尔手一伸，风暴战斧飞到其手中。　　公元2028年（终局之战5年后）　　尼达维　　赤裸着上身的雷神拿着风暴战斧的斧背狠狠的敲打着一块炙热到泛红的金属，每一次敲打都伴随着巨大的闪电。　　“你没有吃饭吗？你手里那块可是你用可是你用雷电锤炼了两年的小恒星，你这样打下去可能只能把锤子留给你的下一代了。”艾崔对着索尔催促道。　　“我还没有后代。”索尔吐槽道，手上更加卖力。　　公元2029年（终局之战6年后）　　尼达维　　索尔举起了一把和之前雷神之锤几乎没有分别的锤子，开心的笑了起来，像是个孩子。　　这一刻索尔仿佛回到他第一次拿到雷神之锤的那一天，父亲母亲弟弟都在，都在为他感到高兴。　　“你还是真是个老派的人。”艾崔看着索尔打造出了和之前一模一样的锤子，有些无语。虽说这锤子模样相似，但是威力可是天差地别。　　“可能是因为和某个老派的人相处的太久了。”索尔的脑海中带着星星的盾牌一闪而过。　　“谢谢，我也要走了。”索尔仅仅的抱住了艾崔，道别着。　　“你真的要去找她了吗？那很危险，你的父亲奥丁曾和我说过，那是唯一一个差点夺走他王位的人。”艾崔显得有些担忧。　　“有些东西，我得亲手拿回来。”索尔目光望向宇宙，飘忽了起来。　　阿斯加德　　一道巨大的彩虹光芒照耀在烈焰废墟的阿斯加德，索尔的身影从光芒中慢慢显现，而一个披头散发的女人望向索尔。　　“好久不见了，姐姐。”索尔微笑着看着面前这个自己唯一的亲人，他知道以苏尔特尔的智商是不可能杀的掉他姐姐这个怪物的，更何况就连奥丁都只能将她封印。　　“哦，我亲爱的弟弟，我们有好大的一笔账需要清算清算了。”海拉拉起了她的头发，漏出半张已经被烧焦的不成人样的脸，狰狞的看着索尔。　　“那我可能会让你失望了，姐姐。”索尔一只手高举斧头，一只手高举锤子，眼中雷电狂涌，巨大的闪电包裹住他的身体，慢慢的腾空，这一次的雷电比以往的任何一次都要来的凶猛的多。　　公元2030年(终局之战7年后)　　阿斯加德　　一道彩虹的光芒中走出一男一女，正是索尔和卡罗尔，阿斯加德仍旧是一片废墟，只是火焰已经不再了。　　“这就是阿斯加德吗？”卡罗尔好奇的看向索尔，这是她第一次来到阿斯加德。　　“是的，它原来很美的。”索尔的脸上多一条巨大的疤痕，这是她姐姐最后为他留下的礼物，疤痕反倒让索尔看起来更加成熟了。　　“我能感觉到，你打算重建神域吗?我可以帮你，我认识许多无家可归的人。”卡罗尔问索尔。　　“不，九界已经不需要神了，他们需要的是信念。”索尔看起来早就有所打算。　　“什么信念？”　　“复仇者”　　公元2033（终局之战10年后）　　地球　　巨大雷电响彻整个阿斯加德的村落，女武神瓦尔基里揉了揉疲惫的双眼，看到窗外的雷电显的相当的开心。　　“好久不见，我的女王。”索尔站在树林间看着瓦尔基里。　　“这次还走吗？”瓦尔基里对着索尔笑，自从当上了女王，还是第一次笑的这么开心。　　“走的。”索尔说道。　　“还要走吗？”瓦尔基里显得相当的失落。　　“带着你们一起。”索尔微笑道。　　“阿斯加德的人民应当属于阿斯加德。”索尔从背后拔出那把巨大的长剑，半跪着，双手托着长剑放在了瓦尔基里的面前。　　“当然。”瓦尔基里像是得到了救赎一般开心，她感受到了故乡的呼唤，伸手接过了那把代表阿斯加德的长剑。五　　公元2033年（终局之战10年后）　　纽约圣殿　　“十年了，斯特兰奇，你让三大圣殿处在备战状态已经十年了。”王不解看着在半空中冥想的奇异博士，终局之战已经结束了十年，可斯特兰奇十年从未笑过。　　“再等等。”冥想的奇异博士睁开了双眼，双眼满是疲惫和不安。　　“等什么？”　　“一场战斗，一场真正的最后之战。”奇异博士望向圣殿的屋顶，像是要望穿整座圣殿。　　王仍旧无法理解，这十年来根本没有任何邪恶的蛛丝马迹，更别说是魔法的敌人了。　　“我找到了莫度，被黑暗力量侵蚀的莫度。”奇异博士双手握于身后，没有任何动作，身前边有一道金黄色的传送门出现。　　“一念成术。。。你果然是我们之中最优秀的。”王惊讶的看向斯特兰奇，这是他从古一法师身上都没有见到的魔法的高阶释放。　　两人一起踏入了传送门，去寻找那个曾经和他们一起并肩作战，如今迷失在黑暗中的法师。　　公元2033年（终局之战10年后）　　银河系　　护卫队的飞船在太空中横冲直撞，而护卫队飞船的后方有一个金色的人影正穷追不舍。　　“你老实告诉我，白痴熊猫，十多年前你是不是连她的内裤一起偷走了？不然就为了几块电池，十多年了还要派这个长得像奥斯卡小金人的怪物追杀我们吗？”飞船快速移动造成的推背感，把星爵狠狠的束缚在驾驶位上。　　“我怎么知道？那个自大又恶心的女人脑子里装的都是格鲁特的鼻屎，还有你要是再说我是熊猫，我就在你睡着的时候，把你的蛋蛋切下来喂给德拉克斯吃。”坐在另一侧驾驶位的火箭浣熊，因为飞船的惯性，脸上的绒毛在空中乱飞。　　“我是格鲁特”格鲁特一听，显得相当不乐意，十年的时间把格鲁特的声音变的非常雄厚。　　“后面这个金色的人，眼眶也是金色的，没有眼球诶，他好像是一个盲人。”螳螂女回头看着穷追不舍的金色人影说道。　　仔细看这个金色的人影，发现这个人全身皮肤包括长发都是金色的，就连眼睛都散发金黄色的光，看不到眼球。　　“你是白痴吗？盲人能追了我们将近两天吗？”星爵近乎咆哮的呐喊道。　　“什么电池？”一旁的德拉克斯一脸严肃的问道，反射弧长的可以绕飞船两圈。　　“哦，我的上帝。”星云用手扶着自己的额头，自从和这群白痴坐上了同一艘飞船，就没有一天平静过。公元2025年（终局之战两年后）　　瓦坎达境内　　“旺达。”苏睿叫住了旺达，苏睿的身后走出来一个红色面孔，绿色身体带着披风的机器人。　　旺达回头看到他，眼神便呆住了，走上前温柔的抚摸着他的脸颊。　　“我扫描了幻视大部分数据，并且尽可能的还原和补足了，他应当拥有你们的全部回忆。”苏睿对旺达解释道。　　旺达把手轻轻地放在了幻视的额头上，混沌魔法从指间溢出，闭上眼睛感受着。　　“ It is nothing，他并没有回来。”旺达没有从混沌魔法中感受到幻视，失望的痛哭了起来，她知道自己永远的失去了至爱。　　“对不起，旺达，我只是。。。贾维斯。”幻视面无表情的看着痛苦的旺达，他无法理解她的感受，也没有自己的感受。　　公元2033年（终局之战10年后）　　索科维亚　 天空蔚蓝，偶有几片白云点缀，耸立的建筑物挤满了整座城市，索科维亚十多年前那场灾难的痕迹已经完全看不见了。　　落日的余晖照在了旺达美艳的侧脸上，时光没有在她的脸上留下任何痕迹，仅仅只是多了一份妩媚。　　“Hey，威廉、托马斯，不要跑的太远，要回家吃晚饭了哦。”旺达温柔的望向不远处的公园，眼神和语气都充满了宠溺。“好的，妈妈”远处的公园，两个稚嫩的孩童异口同声的说道。一个黑发亚裔，一个银发碧眼。六公元2033年（终局之战10年后）　　果敢境内　　猎鹰身穿蔚蓝色战服，胸前一个白色的五角星，腰间是红白相间的厚重腰带，翅膀也被做成了大红色，而手里握着的正是那面传承百年的振金盾牌。　　山姆面前的是一座废弃的大楼，要知道自从瓦坎达对外开放了科技共享，整个世界科技都在飞速的提升，而如此破旧的大楼已经非常的稀少了。　　“班纳，扫描整座大楼。”猎鹰对着无线电吩咐道。　　“早就发给你了，队长。”班纳坐在一辆面包车里，一只手噼里啪啦的敲打着屏幕，车内的空间很小，班纳巨大的体型只能略微蜷伏的缩在座位上，甚至连头都抬不起来。“下次可以给我搞一辆大点的车吗？你们知道的，我可是个大家伙。”　　猎鹰闭上眼睛大楼的全息投影浮现在脑海中，红色的敌人遍布了整个四层楼，而其中四楼的人数最多。　　“巴基，一楼和二楼的敌人交给你。”猎鹰说完便朝着天空飞去。　　“收到，队长。”冬兵轻点了一下一旁的脸颊，黑色的面罩笼罩住了他的面庞。冬兵从角落里跳了出来，抬起手中M4A1便对着一楼的敌人开始扫射。　　猎鹰的机械翅膀中飞出一个小型的侦察机，两侧还有着银白色的枪管。侦察机径直飞向了三楼，银白色的枪管释放出蔚蓝色的能量炮。　　猎鹰飞到了四楼，手中的盾牌丢出，在人群之中弹来弹去，击倒了不少敌人。　　“Hey，你们被逮捕了。”猎鹰手中一翻，出现了两把乌兹冲锋枪，直指众人。　　片刻后。　　“我这边结束了，山姆，你呢？”冬兵把最后一名敌人的手臂扭断对着无线电说道。　　“有点耐心，好吗？老人家。”猎鹰用翅膀击飞了三个敌人说道。　　班纳所在的面包车被粗暴的打开，一群蒙面黑衣人拿枪指着班纳。　　“我被发现了，队长。”班纳小声的对着无线电说道。　　班纳示意性的指了指自己的右手，说道“伙计们，别开枪，要关爱残疾人。”　　黑衣人们面面相觑，然后毫不犹豫的对着班纳扫射。　　“拜托，你们也太没有公德心了。”子弹打在班纳的身上根本没有太大的效果，左手抓起车内的一排座椅，重重的将面前的黑衣人排飞出去说道“我最讨厌被蚊子咬了。”　　这时，一名抱着一大罐振金的黑衣人背后突然生出机械双翼，向楼外飞去。　　“你放跑了你的兄弟吗？山姆”正在赶来的冬兵正好看到了逃走的敌人。　　“你可以闭嘴吗？老家伙。”猎鹰对着无线电继续说道，“莱拉，到你了。”　　“收到，队长”一个看起来好像20出头的深褐色长发的女孩，手里握着一张大弓，对着无线电说道。　　莱拉闭上眼睛，脑海中浮现出四周的全息投影，而红色的目标正在周围的建筑中低空飞行。　　“我得手了。”莱拉把手中的弓弩拉到满月，对着天空瞄准片刻，然后释放。　　话音刚落，弓箭在空中呈抛物线坠落，精准的打在了敌人机械翅膀的背部。　　“九头蛇万岁。”敌人坠落在了地上，用最后的力气说道，振金滚落到了一旁。　　公元2033年（终局之战10年后）　　复仇者联盟总部　　“队长，果敢丢失的振金已经全部找回了，我们摧毁的也是果敢境内最后一个九头蛇基地了。”班纳拿着报告对着猎鹰娓娓道来。　　“我没有听错吧，这么多年了，你们还在和九头蛇纠缠？九头蛇如果消失了，你们会不会失业？”黑豹以及奥克耶将军走进房间，黑豹对着猎鹰吐槽道。　　“也许吧。”一旁的冬兵怂了怂肩无奈的说道，九头蛇的生命力实在是太顽强了。　　“来这里有何贵干？我尊敬的国王。”猎鹰对着黑豹问道。　　“一件重要的事情，有一个人工智能从瓦坎达境内逃走。”黑豹一边说，一边从手腕上的珠子轻点，人工智能给黑豹留下来的那段录像再次播放了起来。　　“。。。。哦对了，我可不是什么老鼠。”厚重的金属音到此戛然而止。　　猎鹰冬兵两人面面相觑并不知道这是什么。　　只有班纳看到了之后，紧握着仅剩的左臂，咬牙切齿的说道：“奥！创！”七　公元2033年（终局之战10年后）　　复仇者联盟总部　　班纳坐在电脑前翻阅着资料，直到翻到一张写着“守望者计划”的文件时停了下来。这是他和托尼曾经合作时设想的一个计划，可是技术问题未能实现，最后因为潜在危险，所有的数据全部清除，只剩下这一张计划书。　　看着这份文件，班纳目光充满着惆怅，好像回到和托尼共事的时光。　　闪烁的荧屏上一道微不可查的红色电流穿过。　　　林间小屋　　摩根正坐在椅子，手上戴着金属手套，她正在测试自己刚改良的掌心炮。　　“Hey，摩根小姐。”桌旁的面盔投影出幻视的模样。　　“Oh,shit”摩根吓了一跳，掌心炮从手中发射而出，穿过了幻视的投影，把地下室的墙壁打了个大洞。　　“摩根，发生了什么？”波茨的声音从楼上传来。　　“没事，妈妈”摩根连忙应道　　“你是谁？”摩根向幻视问道。　　“我是贾维斯，你爸爸的助理，现在，我是你的助理了。”贾维斯面无表情的说道。　　“什么？助理？你能帮我什么？”摩根问道。　　“everything。”贾维斯没有感情的声音给人莫名的安全感。　　“我妈妈知道这件事情吗？”摩根疑惑的问道。　　“不，波茨女士并不知道，只有你父亲和你知道这件事情。”贾维斯回答道。“你父亲留给了你两样东西，一个是我，另一个，则是一份珍贵的礼物。”　　“什么礼物？”　　“守望者。”　　。。。　　“守望者？这个名字听起来像是另一个世界某种残酷而又老土的组织。”摩根重复着这个名字吐槽道。　　“这是一项非常伟大的计划，如果实现了，全世界都可以实现和平。而这份计划的蓝图，你的父亲留给了你。”贾维斯介绍道。　　“留给了我？什么意思？”摩根疑惑的问道。　　“我不知道，恐怕这只有你可以知晓。”贾维斯看着摩根回答道。　　“为什么他自己不去实现？”摩根继续问道。　　“因为科技水平的不足和史塔克先生严重的焦虑症。”贾维斯的眼中看不出任何的感情。　　“他有焦虑症？”摩根吃惊的问道。　　“是的，非常严重，持续了很长一段时间。”贾维斯回答道。　　摩根若有所思的望向满是繁星的天空。　 。。。　　“我翻遍家里所有的地方，拆掉了我爸爸留给我的所有玩具，根本什么都没有。”摩根满头大汗的坐在地上，周围都是被拆坏掉的玩具。　　“对不起，摩根小姐，这件事情上我恐怕帮不到你。”幻视对着摩根说道。　　摩根躺在地上思考，忽然灵光一现，站起身来，飞奔着出去。　　摩根跑到储物室飞快的搜寻，很快便找到了一个小帐篷，用手拍了拍上面的灰尘。　　“这是我小时候的秘密基地，每一次吃饭我爸爸都会把我从里面抱出来。”摩根坐在地上像是在对贾维斯说，又像是在对自己说。　　“有了。”摩根把手伸进帐篷中寻找，很快便摸到了一个夹层，兴奋的叫到。　　摩根从夹层中那出了一个金属制的公文包，公文包上面有个小型摄像头。　　“我就知道，它需要你的瞳孔识别。”贾维斯在旁边提醒道，语气中有一丝微不可查的焦急。　　摩根把瞳孔对准摄像头，果然有一道蓝光缓缓的扫过眼球，公文包应声打开，里面是一大叠一大叠的蓝色图纸，现在像这样的大叠的文件已经非常稀少了。　　“没想到，我老爸风格这么老派。”摩根晃了晃头，她印象中的父亲是一个特别依赖科技的人，留下来的竟然是一大堆纸质图纸，让人出乎意料。　　“真是谨慎啊”贾维斯小声的说了句。　　“你说什么？”　　“没什么，摩根小姐。”　　摩根翻开守望者计划的封面，第一张图纸上画着的是一个体型巨大的红色战甲，编号01，名称叫做反浩克机甲。　　第二章图纸上画着的是一个拿着金属锤的银色机甲，编号02，名称叫做雷神战甲。　　“这些到底是什么？”摩根疑惑的问贾维斯。　　“The future，我的公主。”贾维斯眼睛紧紧的盯着图纸，语气有着掩饰不住的兴奋。　　公元2033年（终局之战10年后）　　联合国总部　　黑豹坐在联合国会议桌的最中心，罗斯将军坐在一旁，奥克耶将军站在其身后，面前的是各个大国的领导人，而苏睿正在给每一位领导人发放文件。　　“想必大家都对奥创有所耳闻。”黑豹站起身了，身后的荧屏上出现的是上升在半空中的索克维亚。“十多年前差点毁灭地球的人工智能。”　　下面各大国的领导人议论纷纷，他们当然都知道这场影响全世界的灾难，只是不知道这位瓦坎达的国王为什么要提起这么久远的事情。　　“但实际上奥创一直都没有被消灭。”黑豹顿了顿继续说道“早在18年前的那场战争，它被幻视从境外网络驱逐出去的时候，就把自己的核心数据隐藏在了瓦坎达。”说着把奥创留下来的影像资料又放了一遍。　　“怎么可能，奥创怎么有能力逃到瓦坎达？而且在瓦坎达如此高的科技水平面前，18年都没有发现？”日本领导人操着古怪的英文腔不相信道。　　“无限宝石赋予奥创非比寻常的生命力，以至于它的存在高于现有的所有人工智能。而且瓦坎达一直严禁人工智能的开发，这就导致我们对于人工智能的认知和你们相差无几。”黑豹早就知道一定会被追问很多问题。　　“那让幻视再消灭它一次不就行了吗？”一直沉默的中国领导人问道。　　“幻视已经死了，不过你们放心，苏睿公主和班纳博士已经结合瓦坎达和境外的最高科技进行研究了，相信我们很快就有解决的办法。”黑豹缓缓的说道。　　“所以您的意思是？”英国首相问道。　　“因为奥创一直渴望振金。”黑豹深吸了一口气说道。“所以，在奥创的问题得到解决之前，瓦坎达将禁止所有振金的对外发放。”　　话音刚落，桌上领导人们交谈的声音越来越嘈杂。　　“您这样做的话，境外很多产业都将面临倒闭。”英国首相仍旧保持着礼貌。“而且无论是科技还是经济可能都会进入大萧条时代。”　　“相信我，用不了多久，我们就可以消灭奥创。”黑豹安抚的说道。“但是，在此之前，振金的流通关乎着全世界的安危，所以请原谅我的决定。”　　“你有什么证据证明你说的就是事实，万一你只是不想再给我们振金了呢？怕我们的科技水平很快就追上你们？”不知道哪个国家的领导人显的非常激动，旁边也有一众领导人在一旁附议，一时间会议室中嘈杂万分，人性的卑劣在此刻彰显无遗。　　“请各位好好的思考一下，瓦坎达对我们的振金供应是他们的恩赐，而不是他们的义务。”一直没说话的罗斯将军站起身来说道“我们没有权利左右他们的选择。”　　此话一出像是刺在众人良知上的一把利刃，各个领导人都清醒了不少，会议室也安静了许多。　　“但是随意的更改振金的发放与否，这是对我们的一次打击和不尊重。”日本领导人指责道。　　坐在中间的黑豹皱起眉头，突然睁开双眼，凌厉的目光扫向桌子上的众人说道“够了，这从来都不是一次协商，这是瓦坎达对境外的通知。”　　就在这时，黑豹背后的电子屏幕不合时宜的闪烁了起来。　　“你们好，各位人类的领导者们。”奥创残破的金属脸出现在了众人的面前“我想你们可以代表整个人类吧”　　“你想要什么？奥创”黑豹对着荧屏问道。　　“别着急，我的国王，我今天来这里的目的很简单。”奥创不慌不忙的说道“就是告诉全世界，战争，开始了。”　　说完奥创便消失了，会议室中一片安静，只剩下荧屏上滋滋的电流声。　　。。。　　瓦坎达境内　　黑豹忧心忡忡的走在前面，苏睿和奥克耶跟在他的后面。　　“哥哥，既然奥创需要振金，为什么我们不把境外所有的振金全部回收呢？”苏睿仍旧不太理解的问黑豹，她是一个科研人员，对于政治和决策方面的事情可以说是一窍不通。　　黑豹并没有回答妹妹这个浅显的问题，一旁的奥克耶将军向苏睿解释道：“如果我们这样做了，那么不需要奥创的进攻，第三次世界大战就会毁掉人类。”　　。。。　　复仇者联盟总部　　“瓦坎达境外的大量振金失踪，山姆。”黑豹缓步的走进来，对着猎鹰说道。　　“奥创干的？”猎鹰疑惑地问道。“这不可能啊，每个国家都把自己的振金当做宝贝一样保护起来，即便奥创可以控制整个网络，也不可能偷的到吧。”　　“如果有人类帮忙的话，就不一样了。”黑豹缓缓的说道。　　“该死的九头蛇。”身旁的冬兵一下子就明白了到底是谁帮助了奥创，正是这个给他带来无尽痛苦的组织。　　。。。　　摩根穿着红色的战甲在天空翱翔。　　“这种感觉太棒了，贾维斯，谢谢你的战甲。”摩根兴奋的在面盔里说道。　　“不需要谢我，你应当谢谢你的父亲。”贾维斯说道。　　“我想我该回家了。”摩根对着贾维斯说了声，想调整飞行方向回家，但是无论怎么操作，战甲都不听使唤了。　　“发生了什么？贾维斯。”摩根焦急的问道。　　“很抱歉，我的公主，虽然我很喜欢你，但是我现在需要向你借点东西。”贾维斯的声音完全变了，变成了摩根从未听过的，厚重的金属音。　　“借什么？”摩根慌张的问道，她终究是个10多岁的少女。　　“Your life”　　贾维斯操控着战甲带着摩根飞向了远方。　　。。。　　天台上　　冬兵和猎鹰并排的站在一起。　　“巴基，我有些担心。”猎鹰看向远方“我不过是个带着机械翅膀的士兵。”　　“我们需要的就是一个士兵，别担心，伙计，我们相信他的判断，更相信你。”巴基安慰道，最后指着自己的手臂补充道“要知道，我还是个残疾人呢。”　　冬兵和猎鹰相视一笑。　　这时，班纳冲进来对着猎鹰说道“不好了，山姆，摩根失踪了。”　　“是时候准备应战了。”猎鹰大概猜到了摩根的失踪可能和奥创脱不了干系，毕竟奥创和史塔克有着千丝万缕的联系。　　猎鹰掏出了那个退休的弗瑞局长给他的BB机，上面浮现出红蓝相见的Logo。　　。。。　　不知名的星球上　　护卫队飞船冒着烟，引擎已经熄火，笔直的朝这颗荒芜星球的地面坠去。　　“伙计们，有史以来最糟糕的迫降要开始了。”火箭浣熊对着身后的众人说道。　　“这根本就是坠落好吗”星爵咆哮着对火箭浣熊说道。　　“差不多。”即便是面对绝境，火箭浣熊仍旧一副无所谓的样子怂了怂肩膀。　　护卫队飞船的后面还绑着一个拿着枪的壮汉，正是德拉克斯。　　“谁能告诉我德拉克斯为什么又跑到飞船外面了？”星爵对着身后的众人没好气的问道。　　“他说他可以打烂后面那个小金人的屁股。”螳螂女解释道。　　“我是格鲁特。”一旁的格鲁特对着星爵说道。　　“他确实是一个白痴，格鲁特。”星爵对于格鲁特的评价表示肯定。　　“我去救他。”星云站起来紧紧的拉住了捆住德拉克斯的救生带，庞大的拉扯力好像要把星云的身体扯开“我总有一天会把你的头盖骨给做成刀鞘的，你这个该死的蠢货。”　　“这太有趣了。”在空中飘荡的德拉克斯开心的说道，周边的空气不断的灌入他的嘴中。　　飞船狠狠的撞击在地面上，虽然没有变成一堆残骸，但是确实无法启动了。　　“拜托，不是吧”火箭浣熊刚才坠落的强大冲击波中缓过来，就看到一道金黄色的身影冲向他们的飞船，绝望的闭上了眼睛。　　但是，死亡好像并没有如期而至，浣熊睁开眼睛看到的是一个穿着红蓝战服的女人接住了金色人影的拳头。　　“为什么你们总是麻烦不断？”这个救了他们的女人正是惊奇队长卡罗尔。　　“可能是因为我们都不怎么理发吧。”火箭浣熊即便在如今还在吐槽着卡罗尔的短发。　　卡罗尔一拳将金色的人影打飞到外太空，星爵众人从飞船上走了下来。　　“让我们来狠狠的打这个小金人的屁股。”星爵变出自己的面具，掏出了自己的双枪，准备反击。　　“冲啊。”德拉克斯掏出了自己的匕首高喊着，冲了出去。　　卡罗尔回头看了看自己身后一群像是马戏团的银河护卫队，无奈的摇了摇头，而转过头的时候，金色的人影不知道什么时候已经悬浮在她的面前了。　　金色的人影一只手抓起了卡罗尔的头，卡罗尔便像是失去了意识一般和金色的人影一起悬浮了起来，看起来像是某种古老的搜魂招数。　　卡罗尔能清晰的感觉到有什么东西进入了自己的大脑窥探，但是她无法反抗。　　银河护卫队的众人纷纷向金色的人影集火，可金色人影的周围好像有一层无形的防护罩，把所有的攻击都化解了。　　这种状态维持了一会，直到卡罗尔头上浮现出红色的头盔以及一个散发着耀眼光芒的鳍。　　“从我的大脑中滚出去。”卡罗尔双拳释放出无比耀眼的光芒击向金色的人影，庞大的力量直接将金色人影击飞到另一个星球上，另一个星球瞬间被粉碎了一半。　　“干的漂亮”星爵在一旁忍不住惊呼道。　　这时，卡罗尔腰间的BB机亮了起来。　　卡罗尔看了一眼BB机，然后看向银河护卫队的众人说道：“我们要出发了，还有更重要的事情等着我们。”　　卡罗尔举着护卫队报废的飞船消失在了茫茫星空中。　　。。。　　“她的力量。。。好特别。”在外太空的废墟中，金色人影懵懂的看着自己的双手，脑海中不断的回忆着在卡罗尔的记忆中看到的断断续续的画面低语道“宝石？地球？”　　这时遥远的外头空一个全身金色的女人说道：“亚当，回来。”　　“对不起，我需要变得更加完整。”亚当看着自己的双手，，然后拒绝了自己主人的命令，切断了联系，向着地球飞去。　　全身金色的女人暴跳如雷，她知道自己费尽心思制造出来的完美生命彻底的背叛了她。（补充一下，这里的亚当不是按照漫画写的。）八（接下来剧情正式进入正轨了，可能故事线有点绕，希望大家耐心一些）。。。　　复仇者联盟总部　 小辣椒抱着一大箱文件走进复仇者联盟的大厅，身后跟着已经生出白发的哈皮，放到了班纳的面前。　　“这是摩根失踪前留在房间里的文件，守望者计划，请你一定要找到她，求你了。”小辣椒哀求着班纳。　　班纳听到守望者三个字，浑身一震，赶忙拿起文件仔细查看。　　“糟了。”班纳失落的靠在座椅上，他知道一切都太迟了。　　“守望者计划到底是什么？”小辣椒焦急的向班纳发问。　　“复仇者战甲，我和托尼希望可以用全自动战甲代替复仇者，从而对地球实行零伤亡的保护，所有战甲的模型都是根据复仇者们的能力而打造的。”班纳解释道。　　“这怎么可能？”身旁的猎鹰惊讶道。　　“放在十年前，确实不可能，但是现在就不一定了。”班纳解释道。　　“我很抱歉，小辣椒，这个计划是我命名的，当初我认为这个计划的可行性非常的高，所以他们两个得到了我的首肯和支持。”带着眼罩的尼克弗瑞补充道。　　“那这又和摩根的失踪有什么关系？”小辣椒焦急的问道。　　“10年前我们因为守望者计划的潜在威胁，把所有资料全部清理，但是托尼留了备份，所以才会有眼前的这份资料。”班纳继续解释道了。　　“托尼太聪明了，也太自负了，他没有舍得放弃这个计划，想把他留给摩根去完成，而奥创猜到了他的想法，这也正是为什么奥创会找上摩根并且带走了摩根。”班纳望着小辣椒说道。　　“那摩根岂不是？”小辣椒突然感觉一阵眩晕，差点就摔倒了，被身后的哈皮扶住了。　　“不会的，摩根暂时不会有任何危险，站在奥创的视角，摩根的生死是一张钳制住复仇者最好的底牌，不到最后一刻他不会动用的。”班纳安慰着小辣椒，和奥创交手的经验让他坚信他所想的和奥创想的一定是一样的。　　“那摩根到底被藏在哪里？我们要怎么去救她？”小辣椒迫切的问道，在她心里除了女儿的安危，奥创和复仇者都不重要了，她的丈夫因为这个世界而牺牲了自己，现在她的女儿就是她的世界。　　“我还不知道，但是我们一定会救出摩根的，我向你保证。”班纳坚定的看着小辣椒。　　“你要知道，这是你们欠他的。”小辣椒丢下最后一句话，转身走掉了。　　。。。　　 阿斯加德复仇者联盟大厅　　“索尔，卡罗尔来了，还带来了一整个动物园。”瓦尔基里对着索尔说道。　　“动物园？”索尔疑惑頓了一下，随即就知道是谁了。“还有塔罗斯，如果你再装成瓦尔基里的样子，你就会知道她为什么叫女武神了。”　　“好吧，又被你发现了。”瓦尔基里慢慢的褪去伪装，显现出一个耳朵尖尖的斯克鲁人。　　而这时，卡罗尔正好走了进来，对着塔罗斯说道：“好久不见，塔罗斯，做复仇者的感觉怎么样？”　　“非常好。”塔罗斯看到自己种族的救命恩人显得相当热情，上前拥抱住了卡罗尔。　　“卡罗尔，找我有什么事？”索尔直奔主题的问道。　　“过来搭个便车。”卡罗尔回答道。“地球需要我们，索尔。”　　“塔罗斯，告诉你的同胞们守护好这里。然后通知所有阿斯加德的复仇者们，准备出发。”索尔二话不说起身向外走去。　　一道巨大的彩虹桥降临在复仇者联盟总部。　　。。。　　复仇者联盟总部　　“以奥创的谨慎程度，摩根一定被藏在了奥创的大本营。”班纳坐在椅子上思索着“那么奥创会选哪里作为自己的大本营呢？”　　“对于奥创来说哪里最安全？”班纳两根绿色的手指不停的摩擦“一定是适合机器作战但不适合人类作战的地方。”　　“温度？高温不行，没有得到足够振金的奥创也没办法抵御高温，那就只有低温！”班纳脑袋中灵光一现。　　“苏睿，用瓦坎达的卫星把南极和北极最详细的热成像图发给我。”班纳焦急的对苏睿说道。　　“稍等”半晌后，苏睿就把数据发来了。“好了。”　　“找到你了。”班纳看着北极热成像图上面巨大的红点笑了笑。　　。。。　　复仇者联盟大厅　　“真正的最终之战开始了，各位。”奇异博士从传送门中走了出来。　　“最终之战？我以为10年前我们就赢了。”班纳诧异的看着奇异博士。　　“不，那只是开始。”奇异博士说道。　　“娜塔莎死了，托尼死了，你告诉我战争还没有结束？那他们的牺牲有什么意义？你不是看过所有的结局吗？为什么明明没有赢下来还要让他们牺牲自己？”班纳越讲越愤怒，上前扯住奇异博士的衣领。　　“我做了我应该做的。”奇异博士的语气中有掩饰不住的悲伤。“我和他们并肩作战了14000605次，不是只有你失去了他们，班纳。”　 班纳知道自己有所失控，这根本不是博士的错，松开手，重重把金属桌锤出一个深坑。　　。。。　　香港圣殿　　“你知道投身黑暗的下场，莫度。”王带着一众法师对身旁黑暗涌动的莫度说道。　　“在黑暗中，死亡仅仅只是开始。”莫度额头的印记越发的浓重，直到最后双眼都一片漆黑。　　“多玛姆”莫度大吼着叫出了这个名字，天空瞬间被黑暗所侵蚀。　　“地球，是我的了。”黑暗中有一双巨大的眼睛睁开。　　。。。　　索克维亚　　“没想到这里还是这么漂亮。”一大群银白色的战甲悬浮在索克维亚的天空中，为首的战甲用奥创的声音说道。　　说完，所有的战甲径直的朝索克维亚俯冲而下，整座城市的存亡危在旦夕。　　“滚出我的城市。”站在地面上的旺达释放出难以想象的庞大魔法，击毁了所有战甲。　　“我们又见面了，旺达。”为首的战甲坠落在旺达的身边，撑起残破的身躯，对着旺达说道。　　“相信我，我一定会再次捏碎你的心脏。”旺达根本不给奥创继续说话的机会，用混沌魔法扯出了奥创的反应堆。　　这时旺达的手机响了，上面是一条来自猎鹰的消息“我们需要你。”　　。。。　　复仇者联盟总部　　蚁人斯科特带着二代黄蜂霍普以及他的女儿三代黄蜂—凯西，走进大厅。　　“拜托，斯科特，你已经把这当做家族企业了吗？”猎鹰看着斯科特的女儿凯西，无奈的对着斯科特说道。　　斯科特不置可否的怂了怂肩。　　“好久不见，可爱的小狗。”火箭浣熊高兴的对着斯科特打招呼。　　“又多了一个白痴。”星云瞥了斯科特一眼。　　“性感的臀部。”德拉克斯盯着凯西的火辣的身材，认真的说道。　　“闭嘴，德拉克斯。”星爵赶忙呵斥。　　。。。复仇者联盟总部　　 几乎所有现存的复仇者们都聚在了一起。　　“索克维亚遭受了奥创的攻击。”猎鹰对着班纳问道“为什么奥创仅仅只攻击了索克维亚？”　　“我不知道”班纳回答道“也许是因为他越来越像人类了。”　　“无论如何，对于奥创最重要的就是瓦坎达无穷无尽的振金，所以瓦坎达一定是我们决战之地。”班纳继续说道。　　“下命令吧，队长。”冬兵对着猎鹰说道。　　“小辣椒和银河护卫队的诸位去营救摩根，记住，银护的各位，你们是营救任务的关键，奥创并不知道你们的到来。”　　“那个孩子需要我，队长”彼得迫切的说道。　　“别冲动，彼得，奥创非常了解你，而且北极不是你的主场。”猎鹰安抚道。　　“索尔和卡罗尔，你们是我们的最强战力，去支援其他地方的人类，防止奥创玉石俱焚。至于博士，我想你应该有更重要的事情要做。”　　“黑暗终至”博士看向远方的香港圣殿，他感觉到了黑暗的来临，打开一道传送门离开了。　　“其余的所有人，跟我一起守护瓦坎达！”　　“复仇者联盟！出发！”(接下来的战斗断断续续的存了一些了，尽量不让大家失望。)九瓦坎达境内。　　复仇者站做一排，身后站满了瓦坎达和阿斯加德的战士们。　　“各位，奥创来了。”班纳看着卫星热成像上四周向他们靠拢的红点提醒道。　　“启动防御。”黑豹对苏睿说。　　“我们什么都没有看见。”瓦坎达外的天空一片祥和，地面也是空无一物。　　“他们在地下，他详细了解过瓦坎达之战，他知道瓦坎达防御的弱点。”战争机器在半空中说道，源源不断的突起铺满了地面，地平面都好像被升高了。　　源源不断的银白色战甲铺天盖地的从地底冲了出来，地面、天空都被银白色的战甲填满了，被包围在其中的复仇者们像是在经历末日。　　“holy shit”彼得叫了一句。　　“复仇者们！迎战！”猎鹰率先飞到高空。　　“瓦坎达Forever！”黑豹率领瓦坎达的战士们双手放于胸前，迎向密密麻麻的银白色战甲。　　“这感觉还真让人熟悉。”冬兵晃了一下脑袋。　　。。。　　“这个大家伙就交给我吧。”班纳迎向了银白色的反浩克战甲。　　“多年不见，你看起来非常的脆弱啊，班纳。”反浩克战甲盯着班纳的右手说道。　　“我可不仅仅是班纳”班纳举起左手朝着反浩克战甲走去。“我还是。。”　　“Holk！！”　　班纳的左手重重的和反浩克战甲的右手对撞在一起，巨大气浪激起了层层灰尘。　　“有时间，还是得多运动运动。”班纳没忍住的咳了一声，小声的喃喃道。　　。。。　　“拜托，不是吧，史塔克先生。”彼得无奈的看着那个背后有着六只蛛矛的银白色机甲，飞快的向自己爬过来。　　“我可是升过级的。”皮特也亮出了自己战服的六只蛛矛向战甲奔去。　　。。。　　一个和普通人类差不多大小的银白色战甲正瞄准着瓦坎达的战士，战甲拥有一双巨大的眼睛，飞速的转动捕捉着敌人的动作，手中一把金属弩飞快射出箭矢。　　“别东张西望的，你的敌人是我。”莱拉拿着巨大的弓，不断的拉弓射出，每一次拉弓都会生出一只蔚蓝色的箭矢，每一只箭矢都直指银白色战甲的要害。　　。。。　　“你们这些该死的金属虫子，我要把你们做成串烧。”巨大化的蚁人挥舞着四肢，每一次都会击毁一大片银白色战甲。　　“可不是只有你一个人有绝技。”一个和蚁人差不多庞大的战甲从地底爬了出来，一拳打在了蚁人的脸上。　　“情况可不太妙了。”被打倒在地的蚁人缓缓的爬起来。　　。。。　　“她的动作太快了。”冬兵艰难的抵挡着一个女性战甲高频率的近身攻击。　　“You are so weak。”女性战甲一个缠绕用腿紧紧夹住冬兵的脖子。　　冬兵有一种窒息的感觉。　　。。。　　“你好，新的领导者。”银白色战甲飞出一面盾牌和猎鹰的盾牌在空中碰撞，然后飞回各自的手里。　　“我不是很想和你聊天。”猎鹰从而中俯冲而下，背后的双翼疯狂的击打在战甲的盾牌上，火花四射。　　。。。　　“和他比起来，你像是块漏电的电池。”瓦尔基里一剑挑飞了夹杂着雷电的金属锤，金属锤飞回战甲手中。　　瓦尔基里双剑交叉于胸前迎向拿着金属锤的战甲。　　。。。　　旺达混沌魔法环绕于双手，每一次挥动都是一大片战甲被粉碎。　　“让我们好好的叙叙旧。”唯一一个鲜红色的巨大战甲从地底爬出，战甲的手中竟然有金黄色的能量波动就像是在操纵魔法，钳制住了旺达操控的混沌魔法。　　“这不可能。”浩克看着奥创的鲜红色战甲说道。　　“那是什么？班纳。”猎鹰也看到了那太庞大的战甲。　　“这是。。。凤凰战甲，我和托尼在研究心灵宝石的时候，发现了一种只存在理论中的力量。”班纳一边抵抗着反浩克战甲，一边说道。“凤凰之力，这是一种和旺达的混沌魔法对等的力量，但是仅限于理论中，凤凰战甲也仅仅只是个想法。”　　“哦，它现在有了一个更好听的名字——反凤凰战甲。”庞大的鲜红战甲对着众人说道。　　“为什么奥创可以在这么短的时间内制作出来？”猎鹰不解的问道。　　“因为他和我的力量一样，都来自于心灵宝石。”旺达艰难的用混沌魔法抵御着战甲释放的凤凰之力，这是她第一次碰到可以和混沌魔法抗衡的力量。　　。。。　　香港圣殿　　“卑微的小虫子，我们又见面了。”天空的黑暗中一双巨大的眼睛看着博士。“我很好奇，没有阿戈摩托之眼的你，要如何和我抗衡？”　　“Use magic”奇异博士双手生出两道金黄色的结界，这是五年来他第一次结手印施展魔法。　　。。。　　“维罗妮卡，开放全部权限，启动‘最后的派对’”身穿宝蓝色战甲的小辣椒在面盔中命令道。　　“收到，波兹女士。”一个温柔的女声在面盔中回应道。　　远处的林间小屋从中间分开，漏出一个巨大的隧道，一个个不同型号的MK战甲从其中飞了出来，不多不少刚好99台，而加上小辣椒，正好是一百台。　　一个庞大的的铁人军团向着北极进发，而铁人军团的身后，是一台隐形的昆式战机。十　。。。　　太平洋上　　“你到底是谁？”卡罗尔看着面前穷追不舍的金色人影，开启了双星模式问道。　　“亚当”亚当面无表情的说道。　　“你到底想要什么？”卡罗尔疑惑的问道，亚当给她一种很奇怪的感觉。　　“Soul”亚当说道。　　两人在太平洋上空疯狂的对撞，巨大的冲击波在太平洋形成了海啸。　　。。。　　北极　　“hey，小姑娘，还记得叔叔吗？”火箭浣熊小心翼翼的走到困住摩根的战甲面前。　　“拜托，别像个恋童癖一样，好吗？”星爵听到一阵干呕。“你尝试去做一个长辈的样子，太让人恶心了。”　　“你们可以迟一点再叙旧吗？虽说我们阻断了整个基地和外部的联系。”星云说道。“但是光是基地里面这些机器人，就能轻易的撕碎我们。”　　“对不起。”摩根对着来救她的众人说道。　　“Hey，小姑娘，别道歉。”德拉克斯说道“反正道歉也没有用。”　　一旁的格鲁</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一公元2033年（终局之战10年后），瓦坎达境内，一个消瘦的女人正面对着聆郎满目的电子仪器不停的摆弄。　　&lt;br&gt;“我可爱的妹妹，今天过得如何？”黑豹迈着健硕的步伐缓缓的向着瓦坎达最先进的实验室中心走去，黑豹身后跟着的奥可耶侍卫
    
    </summary>
    
      <category term="杂货" scheme="https://mayi21.github.io/categories/%E6%9D%82%E8%B4%A7/"/>
    
    
      <category term="杂货" scheme="https://mayi21.github.io/tags/%E6%9D%82%E8%B4%A7/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-1</title>
    <link href="https://mayi21.github.io/2019/07/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://mayi21.github.io/2019/07/21/机器学习/</id>
    <published>2019-07-21T14:37:53.718Z</published>
    <updated>2019-07-21T14:37:53.913Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="ML" scheme="https://mayi21.github.io/categories/ML/"/>
    
    
      <category term="机器学习" scheme="https://mayi21.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Docker-1</title>
    <link href="https://mayi21.github.io/2019/07/21/docker/"/>
    <id>https://mayi21.github.io/2019/07/21/docker/</id>
    <published>2019-07-21T14:30:46.634Z</published>
    <updated>2019-07-21T14:49:09.871Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.下载镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull ubuntu</span><br><span class="line">sudo docker pull ubuntu:14.04 (by appoint tag pull given image)</span><br><span class="line">(以上命令相对应于) sudo docker pull registry.hub.docker.com/ubuntu:latest (下载注册服务器为registry.hub.docker.com中ubuntu仓库的下载标记为latest的镜像)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>2.运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -t -i ubuntu /bin/bash    #(下载镜像到本地，利用镜像创建一个容器，在中运行bash应用)</span><br></pre></td></tr></table></figure></p><p>3.查看镜像信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure></p><p>4.更改镜像的tag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker tag dl.dockerpool.com:5000/ubuntu:latest ubuntu:latest</span><br></pre></td></tr></table></figure></p><p>5.搜寻镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker search mysql</span><br></pre></td></tr></table></figure></p><p>6.查看镜像信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker inspect 5506de2b643b    #镜像ID</span><br></pre></td></tr></table></figure></p><p>7.删除镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rmi IMAGE[IMAGE...] #其中</span><br><span class="line">sudo docker rmi dl.dockerpool.com:5000/ubuntu</span><br></pre></td></tr></table></figure></p><p>8.退出容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exit #退出并且关闭容器</span><br><span class="line">Ctrl + P + Q #退出但不关闭容器</span><br><span class="line">docker attach &lt;ID&gt; #重新进入未关闭的容器</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.下载镜像&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo docker pull ubuntu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo docker pull ubuntu:14.04 (by appoint tag pull given image)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(以上命令相对应于) sudo docker pull registry.hub.docker.com/ubuntu:latest (下载注册服务器为registry.hub.docker.com中ubuntu仓库的下载标记为latest的镜像)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://mayi21.github.io/categories/Docker/"/>
    
    
      <category term="Docker开发" scheme="https://mayi21.github.io/tags/Docker%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Spark-1</title>
    <link href="https://mayi21.github.io/2019/06/06/Spark/"/>
    <id>https://mayi21.github.io/2019/06/06/Spark/</id>
    <published>2019-06-06T11:40:08.745Z</published>
    <updated>2019-07-21T14:29:22.695Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.分布式数据的容错性处理较为常用的方法有检查节点和更新记录。<br>检查节点的方法是对每个节点逐个进行检测，随时查询每个节点的运行情况。好处是便于主节点随时了解人物的真实数据运行情况，坏处就是资源消耗非常大，<a id="more"></a>而且一旦出现问题，需要将数据在不同节点中搬运，反而更加耗费时间从而极大地拉低执行效率。<br>更新记录指的是运行的主节点并不总是查询每个分节点的运行状态，而是将相同的数据存放在不同的节点上面（一般不超过三个），各个工作节点按固定的周期更新在主节点中的运行记录，如果在一定的时间内主节点查询到的数据的更新状态超时或者有异常，则在存储相同数据的不同节点上重新启动数据计算工作。缺点在于如果数据量过大，更新数据和重新启动运行任务的资源耗费也相当大。<br>2.Spark架构<br>Driver:运行Application的main函数并且创建SparkContext；<br>Client:用户提交作业的客户端；<br>Worker:集群中任何可以运行Application代码的节点，运行一个或多个Executor的进程；<br>Executor:运行在worker的Task执行器，Executor启动线程池运行Task，并且负责将数据存在磁盘或者内存中。每个Application都会申请各自的Executor来处理任务；<br>SparkContext:整个应用的上下文，控制应用的声明周期；<br>RDD:Spark的基本计算单元，一组rdd形成执行的有向无环图RDD Graph；<br>DAG Scheduler:根据job构建基于stage的dag工作流，并提交stage给taskscheduler；<br>TaskScheduler:将Task分发给Executor执行；<br>SparkEnv:线程级别的上下文，储存运行时的重要组件的引用。  </p><hr><p>华丽分割线</p><hr><ol><li>小测试中<br>1.scala中的nothing是所有类的子类。<br>2.ClusterManager是主节点。<br>3.scala反编译后可读可执行，是字节码文件.  </li><li>二次小测试<br>1.stage的切分发生在rdd计算发生shuffle时<br>2.算子量比较：SparkSql &gt; Spark &gt; SparkStreaming<br>3.SparkStreaming的时间窗口是可以有间断的<br>4.在yarn环境中，worker寄宿在container中，worker的生命周期并不受jop的执行情况所决定。<br>5.执行流程如下：1.DAGScheduler对Application进行分析，2.然后根据各RDD之间的依赖关系划分Stage，3.根据这些划分好的Stage，对应每个Stage会生成一组Task，4.将Task Set提交给TaskScheduler，5.TaskScheduler启动Executor进行任务的计算<br>6.聚类是从已知到未知，分类是从未知到已知  </li></ol><p>在idea构建sparkjar包：<br>1.在idea中新建一个scala的sbt工程，然后再build.sbt中引入合适的spark的包（此处有点像maven）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name := &quot;spark-idea&quot;</span><br><span class="line">version := &quot;0.1&quot;</span><br><span class="line">scalaVersion := &quot;2.12.8&quot;</span><br><span class="line">libraryDependencies ++= Seq(</span><br><span class="line">  &quot;org.apache.spark&quot; %% &quot;spark-core&quot; % &quot;2.1.2&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>2.新建一个scala的object，然后写上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val conf = new SparkConf().setAppName(&quot;WordCount&quot;)</span><br><span class="line">val sc = new SparkContext(conf)</span><br></pre></td></tr></table></figure></p><p>3.配置jar包，在ProjectStrcture的Artifacts中新建一个空jar包，然后选择当前的main函数，然后就可以build了<br>4.首先启动spark的master<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/start-master.sh</span><br></pre></td></tr></table></figure></p><p>然后启动spark的worker<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-class org.apache.spark.deploy.worker.Worker spark://localhost:7077</span><br></pre></td></tr></table></figure></p><p>然后提交作业<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-submit --master spark://localhost:7077 --class &lt;加上包名&gt;.WordCount /home/lucy/learnspark.jar</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.分布式数据的容错性处理较为常用的方法有检查节点和更新记录。&lt;br&gt;检查节点的方法是对每个节点逐个进行检测，随时查询每个节点的运行情况。好处是便于主节点随时了解人物的真实数据运行情况，坏处就是资源消耗非常大，
    
    </summary>
    
      <category term="Spark" scheme="https://mayi21.github.io/categories/Spark/"/>
    
    
      <category term="Spark开发" scheme="https://mayi21.github.io/tags/Spark%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Python-1</title>
    <link href="https://mayi21.github.io/2019/06/06/Python-1/"/>
    <id>https://mayi21.github.io/2019/06/06/Python-1/</id>
    <published>2019-06-06T10:28:46.040Z</published>
    <updated>2020-01-17T13:10:31.440Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Q.调用方法带括号和不带括号的区别？<br>A.带括号返回的是计算结果，是一个值；不带括号返回的是这个函数体。<a id="more"></a>  </p><hr><p>华丽分割线</p><hr><p>1.list去重：<br>List(Set(List))<br>快速构建list<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [i for i in range(1, 10)]</span><br><span class="line">(或者)  </span><br><span class="line">def some_function(a):</span><br><span class="line">    return (a+5)/2</span><br><span class="line">a = [some_function(i) for i in range(10)]</span><br><span class="line">(这种用法)</span><br><span class="line">a = [i for i in range(20) if i%2 == 0]</span><br><span class="line">```  </span><br><span class="line">字典合并，如果键有相同的，第一个字典的值会被覆盖</span><br></pre></td></tr></table></figure></p><p>dict1 = { ‘a’: 1, ‘b’: 2 }<br>dict2 = { ‘b’: 3, ‘c’: 4 }<br>merged = { <strong>dict1, </strong>dict2 }<br>print (merged)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">统计出现最多的数字</span><br></pre></td></tr></table></figure></p><p>test = [1, 2, 3, 4, 2, 2, 3, 1, 4, 4, 4]</p><h1 id="count-argument-返回的是argument出现的次数"><a href="#count-argument-返回的是argument出现的次数" class="headerlink" title=".count(argument):返回的是argument出现的次数"></a>.count(argument):返回的是argument出现的次数</h1><p>print(max(set(test), key = test.count))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用map()</span><br></pre></td></tr></table></figure></p><h1 id="map-function-something-iterable"><a href="#map-function-something-iterable" class="headerlink" title="map(function, something_iterable)"></a>map(function, something_iterable)</h1><p>def upper(s):<br>    return s.upper()<br>mylist = list(map(upper, [‘sentence’, ‘fragment’]))<br>print(mylist)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用Counter</span><br></pre></td></tr></table></figure></p><p>from collections import Counter<br>mylist = [1, 1, 2, 3, 4, 5, 5, 5, 6, 6]<br>c = Counter(mylist)<br>print(c)<br>```</p><h2 id="—"><a href="#—" class="headerlink" title="—-"></a>—-</h2><p>1.math库的高等特殊函数<br>函数 | 数学表示 | 描述</p><ul><li>| :-: | -<br>math.erf(x) | $\frac{2}{\sqrt{\pi}}\lmoustache_{0}^{x}e^{-t^{2}}dt$ | 高斯误差，应用于概率论，统计学等领域<br>math.erfc(x) | $\frac{2}{\sqrt{\pi}}\lmoustache_{0}^{\infty}e^{-t^{2}}dt$ | 余补高斯误差函数，math.erfc(x)=1-math.erf(x)<br>math.gamma(x) | $\lmoustache_{0}^{\infty}x^{t-1}e^{-x}dx$ | 伽玛函数，也叫欧拉第二积分函数<br>math.lgamma(x) | ln(gamma(x)) | 伽马函数的自然对数  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Q.调用方法带括号和不带括号的区别？&lt;br&gt;A.带括号返回的是计算结果，是一个值；不带括号返回的是这个函数体。
    
    </summary>
    
      <category term="Python" scheme="https://mayi21.github.io/categories/Python/"/>
    
    
      <category term="Python开发" scheme="https://mayi21.github.io/tags/Python%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>java笔记-1</title>
    <link href="https://mayi21.github.io/2019/05/22/Java-1/"/>
    <id>https://mayi21.github.io/2019/05/22/Java-1/</id>
    <published>2019-05-22T10:47:49.286Z</published>
    <updated>2020-01-16T09:14:25.205Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Q.String,StringBuffer和StringBuilder的区别<br>A.String是字符串常量，而StringBuilder和StringBuffer是字符串变量；由String创建的字符内容不可改变，而由StringBuffer和StringBuilder创建的字符内容可以改变；StringBuffer是线程安全的，<a id="more"></a>StringBuilder是线程不安全的，但在可能的情况下先建议使用此，因为不需要考虑同步问题，所以会更快，String是线程安全的，但是线程安全主要是针对那些需要维护内部状态改变的类，而String是不可以改变的，所有操作都不会对它进行修改，所以一般不讨论String的线程安全问题。</p><p>Q.Jdk和Jre的区别？<br>A.jre：java runtime environment，java的运行环境。jdk：java develope kit，java开发工具包。当你需要运行java程序时，只需要安装jre即可；当你想要编写java程序时，需要安装jdk。</p><p>Q.java的IO流有哪几种？<br>A.根据数据流向：输入流和输出流；数据的格式：字符流和字节流；</p><p>Q.String类为什么要声明为final？<br>A.这样就不能够继承，也就没法修改这个类的实现，就更加安全。</p><p>Q.netty和tomcat的区别在于？<br>A.通信协议。Tomcat是基于http协议的，实质上是一个基于http的web容器；但是netty不一样，它能够通过编程自定义各种协议，因为netty能够通过自己的codec来解码/编码字节流。</p><p>Q.Thread使用run()和start()启动的区别？<br>A.start():真正实现了多线程运行，通过调用Thread类的start()方法来启动一个线程，这时此线程是处于就绪状态，并没有运行。然后通过此Thread类调用方法run()来完成其运行操作的，这里方法run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程终止。然后CPU再调度其它线程。<br>run():不开启新的线程，只是按部就班的调用对象的run()方法，此时只有一个主线程，只有等run()方法执行完毕才会执行下面的代码。</p><p>Q.多次start一个线程会出现什么问题？<br>A.正常启动一次后，再次启动抛出”java.lang.IllegalThreadStateException”的异常，在调用start方法时，会首先判断threadStatus是否等于0，如果不等于0，就抛出异常。  </p><p>Q.线程安全的map？<br>A.ConcurrentMap，SynchronizedMap，HashTable。<br>HashTable的get和put方法都被synchronized关键字修饰，说明他们是方法级别的阻塞，它们占用共享资源锁，所以导致同时只能一个线程操作get或者put，而且get/put操作不能同时执行，所以这种同步的集合效率非常低，一般不建议使用这个集合。<br>SynchronizedMap的实现方式是加了个对象锁，每次对HashMap的操作都要先获取这个mutex的对象锁才能进入，所以性能也不会比HashTable好到哪里去，也不建议使用。<br>ConcurrentMap是最推荐使用的线程安全的Map，也是实现方式最复杂的一个集合，每个版本的实现方式也不一样，在jdk8之前是使用分段加锁的一个方式，分成16个桶，每次只加锁其中一个桶，而在jdk8又加入了红黑树和CAS算法来实现。  </p><p>Q.foreach(增强型for循环的底层实现方式)？<br>A.通过对代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (Integer i : list) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>反编译得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i;</span><br><span class="line">for(Iterator iterator = list.iterator(); iterator.hasNext(); System.out.println(i))&#123;</span><br><span class="line">    i = (Integer)iterator.next();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按照执行顺序进行拆解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer i：定义一个临时整型变量i  </span><br><span class="line">Iterator iterator = list.iterator()：获取迭代器</span><br><span class="line">iterator.hasNext()： 判断迭代器中是否有未遍历过的元素</span><br><span class="line">i = (Integer)iterator.next()： 获取第一个未遍历的元素，赋值给临时变量i</span><br><span class="line">System.out.println(i)：输出临时变量i的值</span><br></pre></td></tr></table></figure></p><p>通过反编译得到，java底层的foreach循环是通过迭代器模式实现。<br>(注意：使用迭代器删除元素时要注意使用不当可能发生<code>ConcurrentModificationException</code>异常,Iterator是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 Iterator 会马上抛出java.util.ConcurrentModificationException异常。所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用 Iterator 本身的方法 remove() 来删除对象，Iterator.remove() 方法会在删除当前迭代对象的同时维护索引的一致性。<br>正确的在遍历的同时删除元素的姿势：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Student&gt; stuIter = students.iterator();    </span><br><span class="line">while (stuIter.hasNext()) &#123;    </span><br><span class="line">    Student student = stuIter.next();    </span><br><span class="line">    if (student.getId() == 2)    </span><br><span class="line">        stuIter.remove();//这里要使用Iterator的remove方法移除当前对象，如果使用List的remove方法，则同样会出现ConcurrentModificationException    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>)。  </p><p>Q.MySql数据库索引的实现原理？<br>A.MySql数据库支持多种索引类型，如BTree(平衡搜索多叉树)索引，B+Tree索引，哈希索引，全文索引</p><p>Q.静态代码块和主函数？<br>A.静态代码块先执行，然后执行主函数；静态代码块中前面的先执行，后面的后执行。  </p><p>Q.Session与Cookie的区别？<br>A.Session是存放在服务器端，所以会占用服务器的资源，Cookie是存放在客户端；Cookie单个限制4k大小，Session没有大小限制。</p><p>Q.什么是序列化？什么情况下需要序列化？为什么HttpSession中对象要序列化？那些不会序列化？<br>A.为了保存内存中对象的状态，并且可以把保存的对象状态再读出来，虽然自己有各种各样的办法保存，但是java提供一种官方的保存方法，那就是序列化；当你想把内存中的对象保存到文件或者数据库时，当你想用RMI(Remote Method Invocation)传输对象时，当你想用套接字在网络上传输对象时；因为Session是用来传输各种值和对象的，对象是不能通过网络传输，所以必须序列化。(相关注意事项：当一个父类实现序列化，子类自动实现序列化，不需要显示实现Serializable接口；当一个对象的实例变量引用其他对象，序列化该对象时，也把引用的对象序列化；并非所有的对象都可以序列化。)；当使用transient关键字时，是不会序列化，还有static关键字不会序列化，因为声明为static的变量是属于类的，而序列化是保存对象的状态。</p><p>Q.RMI(Remote Method Invocation)与RPC(Remote Procedure Call Protocol)的区别？<br>A.适用语言范围不同：<br>RPC设计在应用程序间通信的平台中立的方式，不会理会操作系统之间的差异，即支持多种语言。<br>RMI是基于java虚拟机的，所以只支持java语言。<br>调用结果的返回形式不同：<br>RPC不支持对象的概念，传送到RPC服务的消息由外部数据表示语言表示，这种语言抽象了字节序类和数据类型之间的差异<br>RMI允许返回Java对象以及基本数据类型<br>方法调用方式不同：<br>RMI中是通过在客户端的Stub对象作为远程接口进行远程方法的调用。每个远程方法都具有方法签名。如果一个方法在服务器上执行，但是没有相匹配的签名被添加到这个远程接口(stub)上，那么这个新方法就不能被RMI客户方所调用。<br>RPC中是通过网络服务协议向远程主机发送请求，请求包含了一个参数集和一个文本值，通常形成“classname.methodname(参数集)”的形式。RPC远程主机就去搜索与之相匹配的类和方法，找到后就执行方法并把结果编码，通过网络协议发回。</p><p>Q.HashMap怎么put()和get()元素？<br>A.HashMap的put实现:根据key的hashcode计算key值的hash值，根据hash值插入到表中的位置，如果该位置有元素，便以链表的方式存储，新加入的元素放在链表头；最先加入的元素放在链表尾。HashMap的get实现:根据key的hashcode值计算hash值，然后找到在表中的位置，然后通过equals方法，逐个寻找在链表中的位置。</p><p>Q.Collections.sort()和Arrays.sort()采用哪种排序方式？<br>A.Collections.sort()采用增强型归并排序法；Arrays.sort()针对基本数据类型采用快速排序法，对象数组使用归并排序。</p><p>Q.HashSet怎样保证所存元素单一？<br>A.根据hash码和equals方法：如果hash码值不相同，则说明元素不存在，就存入；如果hash码值相同则进行equals方法判断是否为同一对象，如果判断相等，就不存，如果判断不等，就存入。(hash值是根据hashcode计算到的)。  </p><p>Q.设计模式<br>A.设计模式是一套被反复使用，多数人知晓的，经过分类的，代码设计经验总结。使用设计模式的目的：为了代码的重用性，让代码更容易被别人理解，保证代码可靠性。设计模式分为三大类：创建型模式，结构型模式，行为型模式。<br>创建型模式：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式。<br>结构型模式：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br>行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。<br>其实还有两类：并发行模式和线程池模式。  </p><hr><p>华丽的分割线</p><hr><p>transient关键字：<br>Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的。 </p><p>volatile关键字：<br>volatile仅仅用来保证该变量对所有线程的可见性，但不保证原子性。<br>可见性：声明为volatile变量的值在修改时，所有线程都知道这个变量的值修改了。<br>不保证原子性：修改变量的值实际上分为好几步，而在这几步内是不安全的<br>volatile作为java中的关键词之一，用以声明变量的值可能随时会别的线程修改，使用volatile修饰的变量会强制将修改的值立即写入主存，主存中值的更新会使缓存中的值失效(非volatile变量不具备这样的特性，非volatile变量的值会被缓存，线程A更新了这个值，线程B读取这个变量的值时可能读到的并不是是线程A更新后的值)。volatile会禁止指令重排。</p><p>msyql优化经验</p><ol><li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li><li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</li><li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</li><li>任何地方都不要使用 select <em> from t ，用具体的字段列表代替“</em>”，不要返回用不到的任何字段。</li><li>避免频繁创建和删除临时表，以减少系统表资源的消耗等。</li></ol><hr><p>华丽分割线</p><hr><p>聊一聊HashMap：<br>HashMap实现了Map，Cloneable，Serializable三个接口，继承了AbstractMap，</p><p>聊一聊List，Set，Map存放null值问题。<br>List 集合可以存储null，添加几个，存储几个；<br>Set集合也可以存储null，但只能存储一个，即使添加多个也只能存储一个；<br>HashMap可以存储null键值对，键和值都可以是null，但如果添加的键值对的键相同，则后面添加的键值对会覆盖前面的键值对，即之后存储后添加的键值对；<br>Hashtable不能碰null，不管是值还是键，一见null就报空指针。</p><p>IO：<br>传统的IO分为四类：<br>InputStream，OutputStream的基于字节的IO<br>Reader和Writer的基于字符的IO<br>File基于磁盘的IO<br>Socket基于网络的IO<br>BIO,NIO,AIO的区别。<br>BIO 就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。<br>NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。<br>AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。<br>同步和异步<br>同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。而异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。我们可以用打电话和发短信来很好的比喻同步与异步操作。<br>阻塞和非阻塞<br>阻塞与非阻塞主要是从 CPU 的消耗上来说的，阻塞就是 CPU 停下来等待一个慢的操作完成 CPU 才接着完成其它的事。非阻塞就是在这个慢的操作在执行时 CPU 去干其它别的事，等这个慢的操作完成时，CPU 再接着完成后续的操作。虽然表面上看非阻塞的方式可以明显的提高 CPU 的利用率，但是也带了另外一种后果就是系统的线程切换增加。增加的 CPU 使用时间能不能补偿系统的切换成本需要好好评估。</p><p>同步/异步，阻塞/非阻塞组合<br>组合方式 | 性能分析<br>-| -<br>同步阻塞 | 最常用的用法，使用简单，IO性能一般很差，CPU大部分处于空闲状态<br>同步非阻塞 | 在网络IO是长连接，同时传输数据不是很多的情况下，提升性能非常有效，但会增加CPU消耗，要考虑增加IO性能能不能补偿CPU消耗，也就是系统的瓶颈是在IO还是CPU上<br>异步阻塞 | 在分布式数据经常用，对于同时写多份相同数据的情况下，异步阻塞对于网络IO能够提升效率<br>异步非阻塞 | 组合方式比较复杂，一般在一些非常复杂的分布式情况下使用，像集群之间的消息同步机制，它适合同时要传多份相同的数据到集群的不同机器，同时数据传输量虽然不大，但是却非常频繁，用这种方式性能能够达到顶峰</p><p>传统IO面向流，使用简单，但是性能不足，IO的各种流是阻塞的，当一个线程调用read() or write()时，线程是阻塞的。<br>BIO：<br>同步：发起一个调用后，被调用者未处理完请求后，调用不返回。<br>异步：发起一个调用后，立即得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他请求，被调用者通常依靠事件，回调等机制通知调用者返回结果<br>同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。<br>阻塞：阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。<br>非阻塞：非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。<br>socketServer的accept方法是阻塞的。当有连接请求时，socketServer通过accept方法获取一个socket，取得socket后，将这个socket分给一个线程去处理。此时socket需要等待有效的请求数据到来后，才可以真正开始处理请求。socket交给线程后，这时socketServer才可以接收下一个连接请求。获得连接的顺序是和客户端请求到达服务器的先后顺序相关。<br>NIO:<br>基于事件驱动，当有连接请求，会将此连接注册到多路复用器上（selector）。在多路复用器上可以注册监听事件，比如监听accept、read。通过监听，当真正有请求数据时，才来处理数据。不会阻塞，会不停的轮询是否有就绪的事件，所以处理顺序和连接请求先后顺序无关，与请求数据到来的先后顺序有关<br>BIO与NIO对比：<br>主要对比<br>BIO一个连接，一个线程，非http请求，有可能只连接不发请求数据，此时线程是无用浪费的。<br>BIO处理依赖于连接建立；NIO处理依赖于请求数据的到来。导致执行顺序不同。<br>一个线程处理一个请求<br>BIO：连接请求来，建立socket，等待请求数据到来（t1），处理时间（t2）<br>NIO：连接请求来，注册到selector，设置读监听，等待请求数据（t1），处理时间（t2）<br>此时，两者用时皆为t1+t2，没有区别<br>一个线程处理两个请求<br>第一个请求，等待请求数据（10），处理时间（1）<br>第二个请求，等待请求数据（1），处理时间（2）<br>BIO：用时 10+1+1+2=14，第1个执行完用时10+1，等待第一个执行完处理第2个，用时1+2<br>NIO：用时 1+2+7+1=11， 第二个数据先到，时间 1+2，此时第一个需要等时为10秒，还没到，还需等待7秒，时间为7+1<br>两个线程处理两个请求<br>第一个请求，等待请求数据（10），处理时间（1）<br>第二个请求，等待请求数据（1），处理时间（2）<br>BIO：用时 10+1+2=13，等待第1个请求10，交给工作线程一处理，此时同时接受第2个，等待1秒，处理时间2秒，此间线程一处理时间为一秒，在线程二结束之前就已经结束<br>NIO：用时 1+2+7+1=11，第二个数据先到，时间 1+2，此时第一个还没到，还需等待7秒，时间为7+1<br>如果两个请求顺序相反，则bio和nio一样，都是11秒<br>由此可见由于阻塞等待机制的不同，导致效率不同，主要优化点为，不必排队等待，先到先处理，就有可能效率高一点。<br>BIO如果想要处理并发请求，则必须使用多线程，一般后端会用线程池来支持<br>NIO可以使用单线程，可以减少线程切换上下文的消耗。<br>但是虽然单线程减少了线程切换的消耗，但是处理也变为线性的，也就是处理完一个请求，才能处理第二个。<br>这时，有这么两个场景：<br>后端是密集型的计算，没有大量的IO操作，比如读些文件、数据库等<br>后端是有大量的IO操作。<br>当为第一种场景时：<br>NIO单线程则比较有优势， 理由是虽然是单线程，但是由于线程的计算是并发计算，不是并行计算，说到底，计算压力还是在CPU上，一个线程计算，没有线程的多余消耗，显然比NIO多线程要高效。BIO则必为多线程，否则将阻塞到天荒地老，但多线程是并发，不是并行，主要还是依靠CPU的线性计算，另外还有处理大量的线程上下文。<br>如果为第二种场景，多线程将有一定优势，多个线程把等待IO的时间能平均开。此时两者区别主要取决于以上分析的处理顺序了，显然NIO要更胜一筹。<br>总结<br>NIO在接收请求方式上，无疑是要高效于BIO，原因并非是不阻塞，我认为NIO一样是阻塞的，只是方式不同，先来的有效请求先处理，先阻塞时间短的。此时间可用于等待等待时间长的。<br>在处理请求上，NIO和BIO并没有什么不同，主要看线程池规划是否和理。NIO相对BIO在密集型计算的模型下，可以用更少的线程，甚至单线程。<br><a href="https://blog.csdn.net/wy0123/article/details/79382761" target="_blank" rel="noopener">https://blog.csdn.net/wy0123/article/details/79382761</a></p><p>分布式算法：<br>轮询算法，哈希算法，最少连接算法，相应速度算法，加权法等，常用的就是哈希算法。哈希算法就是对hash结果取余数(hash() mod N):对机器编号从0到N-1，按照自定义的 hash()算法，对每个请求的hash()值按N取模，得到余数i，然后将请求分发到编号为i的机器。但这样的算法方法存在致命问题，如果某一台机器宕机，那么应该落在该机器的请求就无法得到正确的处理，这时需要将当掉的服务器从算法从去除，此时候会有(N-1)/N的服务器的缓存数据需要重新进行计算;如果新增一台机器，会有N /(N+1)的服务器的缓存数据需要进行重新计算。对于系统而言，这通常是不可接受的颠簸(因为这意味着大量缓存的失效或者数据需要转移)。那么，如何设计一个负载均衡策略，使得受到影响的请求尽可能的少呢?一致性哈希将整个哈希值空间按照顺时针方向组织成一个虚拟的环，下一步将服务器的ip或者关键字进行哈希，映射到环上，然后根据数据的key计算哈希同时映射到环上，从此位置顺时针走，遇到的第一个服务器就是该数据所存放的位置。删除或者增加服务器受到影响的只是一部分数据。当服务器过少，且两台服务器在环上的位置比较近，则容易造成数据倾斜的问题，在前的一个服务器得到大量的数据，为了解决这种数据倾斜的问题，我们将一个服务器节点计算多个哈希，每个计算结果的位置都放在环上，称为虚拟节点，这样就能够抑制数据倾斜问题。</p><p>ConCurrentHashMap解析：<br>JDK1.8的底层是散列表+红黑树，支持高并发访问和更新，他是线程安全的，key和value都不允许为空。JDK1.7的实现是segments+HashEntry数组。<br>有了Hashtable为啥需要ConCurrentHashMap？<br>Hashtable是在每个方法上都加上了Synchronized完成同步，效率低下。<br>ConcurrentHashMap通过在部分加锁和利用CAS算法来实现同步。</p><p>Netty小知识。<br>netty具有并发高，传输快，封装好。<br>并发高是因为netty基于NIO</p><p>$d_{1}=\frac{\ln(S_{t}/K)  +(r+\sigma^{2}/2)(T-t)}{\sigma\sqrt{T-t}}$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Q.String,StringBuffer和StringBuilder的区别&lt;br&gt;A.String是字符串常量，而StringBuilder和StringBuffer是字符串变量；由String创建的字符内容不可改变，而由StringBuffer和StringBuilder创建的字符内容可以改变；StringBuffer是线程安全的，
    
    </summary>
    
      <category term="Java" scheme="https://mayi21.github.io/categories/Java/"/>
    
    
      <category term="Java开发" scheme="https://mayi21.github.io/tags/Java%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Centos配置hadoop和spark</title>
    <link href="https://mayi21.github.io/2019/03/23/Linux%E9%85%8D%E7%BD%AEhadoop%E4%B8%8Espark/"/>
    <id>https://mayi21.github.io/2019/03/23/Linux配置hadoop与spark/</id>
    <published>2019-03-23T13:05:17.152Z</published>
    <updated>2019-03-24T03:59:35.673Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前言:大数据学生一枚,hadoop是基础,spark是进阶,到了学spark的时候了,又得重新配置一台服务器了.正好借这次机会,把配置步骤记下来,省得以后再翻老班发的PPT.<br>环境:Centos7 64位,JDK1.8 hadoop2.8.4,scala2.11.6,spark2.4.0<a id="more"></a><br>1.先安装通用工具:yum install lrzsz.安装完成后在Xshell中使用rz命令可选择上传文件,十分方便.<br>2.配置网关:<code>vim /etc/sysconfig/network</code>,应该是空的,添加内容如下<code>HOSTNAME=zzti</code> <code>GATEWAY=192.168.17.2</code>,网关设置也可能不是,自己可能要改一下.<br>3.修改主机名称:<code>vim /etc/hosts</code>,在最前面添加<code>127.0.0.1 zzti</code>.  然后关闭防火墙<code>systemctl stop firewalld</code> 查看防火墙状态的命令:<code>systemctl status firewalld</code>.<br>4.此时重启一下,倒杯水,准备下面一番苦干吧.<code>reboot</code>.<br>5.创建工作目录:<code>mkdir -p /data/zzti</code> <code>ln -s /data/zzti/ /zzti</code> <code>useradd zzti</code> <code>chown zzti:zzti /zzti</code>.<br>6.配置免密登录:<code>ssh-keygen</code>,一路回车到底,然后执行<code>cat ~/.ssh/id_rsa.pub &gt; ~/.ssh/authorized_keys</code>  <code>chmod 644 ~/.ssh/authorized_keys</code>  <code>mkdir /home/zzti/.ssh</code> <code>cp ~/.ssh/*  /home/zzti/.ssh/</code> <code>chown -R zzti:zzti /home/zzti/.ssh</code> <code>chmod 700 /home/zzti/.ssh</code>,此过程应该没什么错误.<br><strong>下面操作在zzti用户下完成 <code>su zzti</code></strong><br>7.上传JDK（此处省略无数字,自己找jdk,上传命令rz）,然后解压<code>tar -zxvf jdk-8u181-linux-x64.tar.gz</code>,更换自己的jdk版本,建立软连接,方便操作<code>ln -s jdk1.8.0_181/ jdk</code>.<br>8.上传hadoop,然后解压<code>tar -zxvf hadoop-2.8.4.tar.gz</code>,建立软连接 <code>ln -s hadoop-2.8.4 hadoop</code>.配置环境变量:<code>vim ~/.bashrc</code>,在最后面加上如下的内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/zzti/jdk/ </span><br><span class="line">export HADOOP_HOME=/zzti/hadoop/</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin</span><br></pre></td></tr></table></figure></p><p>然后退出保存,执行<code>source ~/.bashrc</code>,使其生效,然后运行<code>java -version</code>,看到jdk的版本即为成功.<br>9.配置hadoop:<code>cd /zzti/hadoop/etc/hadoop</code>,在core-site.xml的两个configure标签添加如下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/zzti/data/hadoop_tmp&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://zzti:9000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;io.file.buffer.size&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;4096&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">      &lt;name&gt;ha.zookeeper.quorum&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;zzti:2181&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br></pre></td></tr></table></figure></p><p>保存退出后,继续编辑hdfs-site.xml,<code>vim hdfs-site.xml</code>,在configure标签之间添加如下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.nameservices&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;zzti-cluster&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;zzti:50090&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;file:///zzti/data/hadoop/name&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;file:///zzti/data/hadoop/data&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br></pre></td></tr></table></figure></p><p>保存退出.配置mapred-site.xml,因为只有<code>mapred-site.xml.template</code>,先cp一下<code>cp mapred-site.xml.template mapred-site.xml</code>,然后再编辑<code>vim mapred-site.xml</code>,然后老规矩,添加如下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.jobtracker.http.address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;zzti:50030&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;zzti:10020&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;zzti:19888&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br></pre></td></tr></table></figure></p><p>保存退出.编辑yarn-site.xml,<code>vim yarn-site.xml</code>,老规矩添加入下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br></pre></td></tr></table></figure></p><p>到此,配置结束.<br>10.配置hdfs:创建文件夹<code>mkdir /zzti/data/hadoop/name /zzti/data/hadoop/data</code>,<code>echo zzti &gt; slaves</code> <code>cd /zzti/hadoop/bin</code> <code>./hadoop namenode –format</code> <code>cd /zzti/hadoop/sbin</code> <code>./start-all.sh</code>,完成后,输入<code>jps</code>,查看是否出现NameNode,NodeManager,DataNode,ResourceManager,Jps,出现这些即为配置成功.<code>cd /zzti/hadoop/bin</code> 创建hdfs文件夹<code>hadoop fs -mkdir /data</code>,查看是否创建成功<code>hadoop fs -ls /</code>,出现data目录即为创建成功.<br>11.功能测试:就自行进行,在此不做演示.<br><strong>hadoop安装完成</strong><br>下面进行spark的安装<br><strong>依然在zzti用户下操作</strong><br>1.创建目录:<code>mkdir libs</code>,进入libs,<code>cd libs</code>,上传spark和scala,解压spark<code>tar -zxvf spark-2.4.0-bin-without-hadoop.tgz</code>,建立软连接<code>ln -s spark-2.4.0-bin-without-hadoop spark</code>,解压scala<code>tar -zxvf scala-2.11.6.tgz</code>,创建软连接<code>ln -s scala-2.11.6 scala</code>.<br>2.配置环境变量<code>vim ~/.bashrc</code>,添加如下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_HOME=/zzti/libs/spark</span><br><span class="line">export SCALA_HOME=/zzti/libs/scala</span><br></pre></td></tr></table></figure></p><p>在PATH后面添加<code>:$SCALA_HOME/bin:$SPARK_HOME/bin</code>,保存退出.<code>source ~/.bashrc</code>使其生效.<br>3.配置spark,在spark的conf的目录下,<code>mv slaves.template slaves</code>,<code>echo zzti &gt; slaves</code> <code>mv spark-env.sh.template spark-env.sh</code>,编辑spark-env.sh <code>vim spark-env.sh</code>,在文档最后加入如下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop</span><br><span class="line">export YARN_CONF_DIR=$HADOOP_HOME/etc/hadoop</span><br><span class="line">export SPARK_LIBARY_PATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$HADOOP_HOME/lib/native</span><br><span class="line">export SPARK_CLASSPATH=$(/zzti/hadoop/bin/hadoop classpath)</span><br><span class="line">export SPARK_DIST_CLASSPATH=$(/zzti/hadoop/bin/hadoop classpath)</span><br><span class="line">export SPARK_EXECUTOR_INSTANCES=1</span><br><span class="line">export SPARK_EXECUTOR_CORES=1</span><br><span class="line">export SPARK_DRIVER_MEMORY=512M</span><br><span class="line">export SPARK_EXECUTOR_MEMORY=512M</span><br><span class="line">export SPARK_MASTER_HOST=zzti</span><br><span class="line">export SPARK_MASTER_WEBUI_PORT=28686</span><br><span class="line">export SPARK_LOCAL_DIRS=/data/zzti/data/spark/local</span><br><span class="line">export SPARK_WORKER_DIR=/data/zzti/data/spark/work</span><br><span class="line">export SPARK_LOG_DIR=/data/zzti/logs/spark</span><br></pre></td></tr></table></figure></p><p>保存退出.<br>4.启动spark<code>bash /zzti/libs/spark/sbin/start-all.sh</code>,然后输入<code>spark-shell</code>,即可进入操作.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言:大数据学生一枚,hadoop是基础,spark是进阶,到了学spark的时候了,又得重新配置一台服务器了.正好借这次机会,把配置步骤记下来,省得以后再翻老班发的PPT.&lt;br&gt;环境:Centos7 64位,JDK1.8 hadoop2.8.4,scala2.11.6,spark2.4.0
    
    </summary>
    
      <category term="Linux" scheme="https://mayi21.github.io/categories/Linux/"/>
    
    
      <category term="hadoop" scheme="https://mayi21.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>创建支持ssh的镜像服务</title>
    <link href="https://mayi21.github.io/2019/03/11/%E5%88%9B%E5%BB%BA%E6%94%AF%E6%8C%81ssh%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%95%9C%E5%83%8F/"/>
    <id>https://mayi21.github.io/2019/03/11/创建支持ssh服务的镜像/</id>
    <published>2019-03-11T11:18:14.028Z</published>
    <updated>2020-04-01T03:44:54.572Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.先安装docker,这里不再赘述<br>2.使用ubuntu镜像来创建容器:<code>docker pull ubuntu</code>,然后启动容器:<code>docker run -it ubuntu /bin/bash</code><a id="more"></a><br>3.更新一下软件源:<code>apt-get update</code>  <code>apt-get upgrade</code>,然后进行安装<code>apt-get install openssh-server</code><br>4.要是想正常启动服务,需要目录/var/run/sshd存在,手动创建,并启动服务:<code>mkdir -p /var/run/sshd</code>  <code>/usr/sbin/sshd -D &amp;</code><br>5.查看容器的22端口:<code>netstat -tunlp</code>,如果提示命令没有安装,则选择安装:<code>apt-get install net-tools</code>,然后在执行命令就行了.此时端口应该是处于监听状态.<br>6.在root用户目录下创建.ssh目录,并复制需要登录的公钥信息（一般在本地主机用户目录下的.ssh/id_rsa.pub）,先创建文件夹:<code>mkdir root/.ssh</code>,然后复制公钥信息到authorized_keys中,<code>vim /root/.ssh/authorized_keys</code><br>7.创建自启动ssh服务的可执行文件run.sh,并添加可执行权限:<code>vim /run.sh</code>  <code>chmod +x run.sh</code>,run.sh脚本的内容为:<br><code>#!/bin/bash</code><br><code>/usr/sbin/sshd -D</code><br>8.使用<code>Ctrl + p + q</code>退出但并不关闭容器.<br>9.用docker commit命令保存为一个新的sshd:ubuntu镜像:<br><code>docker commit &lt;Image Id&gt; sshd:ubuntu</code>,使用<code>docker images</code>查看本地的镜像<br>10.启动容器,并添加映射端口10022 -&gt; 22,其中10022是宿主机的端口,22是容器的SSH服务监听端口:<code>docker run -p 10022:22 -d sshd:ubuntu /run.sh</code>,启动成功后,在宿主机上看到容器的运行的详细信息.<br>11.在宿主机（192.168.1.200）上或其他主机,通过ssh服务访问10022端口来登录容器:<code>ssh 192.168.1.200 -p 10022</code><br>参考:Docker技术入门与实践<br><img src="https://www.johanadam.workers.dev/Image/img-25cbbc1b772ab5fdb15a25052ed9325b.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.先安装docker,这里不再赘述&lt;br&gt;2.使用ubuntu镜像来创建容器:&lt;code&gt;docker pull ubuntu&lt;/code&gt;,然后启动容器:&lt;code&gt;docker run -it ubuntu /bin/bash&lt;/code&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://mayi21.github.io/categories/Docker/"/>
    
    
      <category term="Docker开发" scheme="https://mayi21.github.io/tags/Docker%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>利用Tensorflow构建自定义的图片分类器</title>
    <link href="https://mayi21.github.io/2019/02/17/Tensorflow%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%9B%BE%E7%89%87%E5%88%86%E7%B1%BB%E5%99%A8/"/>
    <id>https://mayi21.github.io/2019/02/17/Tensorflow构建自定义的图片分类器/</id>
    <published>2019-02-17T10:24:22.525Z</published>
    <updated>2020-01-17T03:54:40.437Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="操作环境-Ubuntu-18-04-Tensorflow-1-7"><a href="#操作环境-Ubuntu-18-04-Tensorflow-1-7" class="headerlink" title="操作环境:Ubuntu 18.04 Tensorflow 1.7"></a>操作环境:Ubuntu 18.04 Tensorflow 1.7</h3><p>1.安装配置Tensorflow或者利用Docker.Tensorflow的安装这里不予多介绍,主要介绍一下Docker的用法.<br>Docker的操作命令如下: <a id="more"></a><br><code>docker pull tensorflow/tensorflow</code><br><code>#指定宿主机的目录和容器的目录,实现文件共享</code><br><code>docker run -it -v /root:/root tensorflow/tensorflow</code><br>2.克隆Git<br><code>git clone https://github.com/googlecodelabs/tensorflow-for-poets-2</code><br><code>cd tensorflow-for-poets-2</code><br>3.准备训练数据,将这些数据存放在tf_files文件夹下,这些数据要求:这个tf_files/&lt;自定义文件夹&gt;下面是子文件夹,子文件夹下面是同种类型的图片(如果是人,那该文件下就是这个人的所有图片,子文件夹的名字就是这些图片的名字)<br>4.准备训练数据.定义图片的大小,<br><code>export IMAGE_SIZE=224</code><br><code>export ARCHITECTURE=&quot;mobilenet_0.50_${IMAGE_SIZE}&quot;</code><br>开始训练.<br><code>python -m scripts.retrain --bottleneck_dir=tf_files/bottlenecks --how_many_training_steps=500 --model_dir=tf_files/models/ --summaries_dir=tf_files/training_summaries/&quot;${ARCHITECTURE}&quot; --output_graph=tf_files/retrained_graph.pb --output_labels=tf_files/retrained_labels.txt --architecture=&quot;${ARCHITECTURE}&quot; --image_dir=tf_files/&lt;自定义的文件夹&gt;</code><br>—how_many_training_steps=500 这个是训练多少步.这里可以不用这个命令,使用默认步数4000步<br>5.验证数据.<br><code>python -m scripts.label_image --graph=tf_files/retrained_graph.pb --image=&lt;自己想检测的图片&gt;</code><br>然后下面就会出现验证的结果.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;操作环境-Ubuntu-18-04-Tensorflow-1-7&quot;&gt;&lt;a href=&quot;#操作环境-Ubuntu-18-04-Tensorflow-1-7&quot; class=&quot;headerlink&quot; title=&quot;操作环境:Ubuntu 18.04 Tensorflow 1.7&quot;&gt;&lt;/a&gt;操作环境:Ubuntu 18.04 Tensorflow 1.7&lt;/h3&gt;&lt;p&gt;1.安装配置Tensorflow或者利用Docker.Tensorflow的安装这里不予多介绍,主要介绍一下Docker的用法.&lt;br&gt;Docker的操作命令如下:
    
    </summary>
    
      <category term="Python" scheme="https://mayi21.github.io/categories/Python/"/>
    
    
      <category term="Tensorflow" scheme="https://mayi21.github.io/tags/Tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>idea开发hadoop</title>
    <link href="https://mayi21.github.io/2018/12/03/idea%E5%BC%80%E5%8F%91hadoop/"/>
    <id>https://mayi21.github.io/2018/12/03/idea开发hadoop/</id>
    <published>2018-12-03T08:54:53.797Z</published>
    <updated>2019-03-24T04:02:39.560Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>下载idea和hadopp源码包<br>新建一个java project,用于hadoop开发,同时需要导入hadoop的相关依赖包<br>java project建成后,点击project structure,进入Dependencies,点击右边的+,点击JARs or<a id="more"></a><br>directories…,添加依赖,这些依赖都可以在share/hadoop下面找到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">common</span><br><span class="line">hdfs</span><br><span class="line">mapreduce</span><br><span class="line">yarn </span><br><span class="line">common/lib</span><br></pre></td></tr></table></figure></p><p>然后是Artifacts,点击+,添加JAR&gt;Empty,名称自定义,然后点击+,点击Module output,在弹出的对话框选择当前的项目,点击保存.<br>接着新建一个Application,Edit Configurations,点击+,新建一个Application,在Main Class中填入<br><code>org.apache.hadoop.util.RunJar</code><br>Working directory当然是选择当前项目的目录了, Program arguments  这个是设置默认参数的会在程序执行的时候传递进去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/home/edmond/workspace/IdeaProjects/Hadoop/HadoopWordCount/out/artifacts/wordcount/wordcount.jar</span><br><span class="line">com.company.Main</span><br><span class="line">input</span><br><span class="line">output</span><br></pre></td></tr></table></figure></p><p>第一个是jar包所在的位置<br>第二个是Main函数所在的类<br>第三四两个参数是由自己决定的（这两个参数会作为args[0]和args[1]传入）<br>点击ok保存.<br>自己写mapper和reducer测试吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下载idea和hadopp源码包&lt;br&gt;新建一个java project,用于hadoop开发,同时需要导入hadoop的相关依赖包&lt;br&gt;java project建成后,点击project structure,进入Dependencies,点击右边的+,点击JARs or
    
    </summary>
    
      <category term="Java" scheme="https://mayi21.github.io/categories/Java/"/>
    
    
      <category term="hadoop" scheme="https://mayi21.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>配置远程访问jupyter</title>
    <link href="https://mayi21.github.io/2018/07/21/%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AEjupyter/"/>
    <id>https://mayi21.github.io/2018/07/21/配置远程访问jupyter/</id>
    <published>2018-07-21T09:58:08.241Z</published>
    <updated>2020-01-17T03:55:10.046Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言-jupyternotebook是一款在线的python编程环境-交互式的编程环境-支持四十多种语言-对于爬虫和分析数据-这样的操作十分方便-众所周知-Jupyter是一个WEB应用-本篇文章教大家在服务器端部署Jupyter并远程访问"><a href="#前言-jupyternotebook是一款在线的python编程环境-交互式的编程环境-支持四十多种语言-对于爬虫和分析数据-这样的操作十分方便-众所周知-Jupyter是一个WEB应用-本篇文章教大家在服务器端部署Jupyter并远程访问" class="headerlink" title="前言:jupyternotebook是一款在线的python编程环境.交互式的编程环境,支持四十多种语言.对于爬虫和分析数据,这样的操作十分方便.众所周知:Jupyter是一个WEB应用.本篇文章教大家在服务器端部署Jupyter并远程访问."></a>前言:jupyternotebook是一款在线的python编程环境.交互式的编程环境,支持四十多种语言.对于爬虫和分析数据,这样的操作十分方便.众所周知:Jupyter是一个WEB应用.本篇文章教大家在服务器端部署Jupyter并远程访问.</h2><p>1.服务器环境:大家可以自行在网上购买服务器,本篇文章使用的服务器环境是Ubuntu 16.04.1 LTS x86_64.<br>2.安全规则:添加安全规则,开放8888端口,记得同时开放22端口,以便在putty,xshell等软件上登陆;然后关联服务器实例.<a id="more"></a><br>3.使用wget下载anaconda,在<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">清华大学开源软件镜像站</a>寻找相应的版本,复制下载链接,然后wget便可.<br>4.使用sh Anaconda3-5.1.0-Linux-x86_64.sh安装Anaconda,安装一路yes便可,安装完成后重启终端,尝试<code>conda</code>.<br>5.输入<code>jupyter notebook --generate-config</code>,生成默认的jupyter配置文件<br>6.安装ipython,<code>sudo apt-get install ipython3</code>.<br>7.启动ipython<code>ipthon</code>,输入<code>from notebook.auth import passwd</code>回车,输入<code>passwd()</code>,此时要求输入密码,这个密码为登陆服务器端jupyter的密码.两次输入后得到密钥(以sha开头的).<br>8.<code>vim /home/ubuntu/.jupyter/jupyter_notebook_config.py</code><br>9.在<code># Configuration file for jupyter-notebook.</code>后另起一行添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.ip=&apos;*&apos;</span><br><span class="line">c.NotebookApp.password = u&apos;密钥&apos;</span><br><span class="line">c.NotebookApp.open_browser = False</span><br><span class="line">c.NotebookApp.port =8888</span><br></pre></td></tr></table></figure></p><p>保存退出.<br>10.安装自动补码,在jupyter notebook未运行的情况下操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install jupyter_contrib_nbextensions</span><br><span class="line">jupyter contrib nbextension install --user --skip-running-check</span><br></pre></td></tr></table></figure></p><p>然后在 Clusters旁边多出 Nbextensions点击进去,找到 Hinterland,打勾即可<br>10.运行Jupyter Notebook <code>jupyter notebook</code>,后台运行<code>nohup jupyter notebook --allow-root &gt; jnotebook.out 2&gt;&amp;1 &amp;</code><br>11.在本地电脑浏览器上输入[<a href="http://you" target="_blank" rel="noopener">http://you</a> server ip:8888]<br>12.输入上面设置的密码.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言-jupyternotebook是一款在线的python编程环境-交互式的编程环境-支持四十多种语言-对于爬虫和分析数据-这样的操作十分方便-众所周知-Jupyter是一个WEB应用-本篇文章教大家在服务器端部署Jupyter并远程访问&quot;&gt;&lt;a href=&quot;#前言-jupyternotebook是一款在线的python编程环境-交互式的编程环境-支持四十多种语言-对于爬虫和分析数据-这样的操作十分方便-众所周知-Jupyter是一个WEB应用-本篇文章教大家在服务器端部署Jupyter并远程访问&quot; class=&quot;headerlink&quot; title=&quot;前言:jupyternotebook是一款在线的python编程环境.交互式的编程环境,支持四十多种语言.对于爬虫和分析数据,这样的操作十分方便.众所周知:Jupyter是一个WEB应用.本篇文章教大家在服务器端部署Jupyter并远程访问.&quot;&gt;&lt;/a&gt;前言:jupyternotebook是一款在线的python编程环境.交互式的编程环境,支持四十多种语言.对于爬虫和分析数据,这样的操作十分方便.众所周知:Jupyter是一个WEB应用.本篇文章教大家在服务器端部署Jupyter并远程访问.&lt;/h2&gt;&lt;p&gt;1.服务器环境:大家可以自行在网上购买服务器,本篇文章使用的服务器环境是Ubuntu 16.04.1 LTS x86_64.&lt;br&gt;2.安全规则:添加安全规则,开放8888端口,记得同时开放22端口,以便在putty,xshell等软件上登陆;然后关联服务器实例.
    
    </summary>
    
      <category term="Python" scheme="https://mayi21.github.io/categories/Python/"/>
    
    
      <category term="Python开发" scheme="https://mayi21.github.io/tags/Python%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>hexo建站</title>
    <link href="https://mayi21.github.io/2018/06/26/hexo%E5%BB%BA%E7%AB%99%E7%AC%AC%E4%B8%80%E6%AD%A5-1/"/>
    <id>https://mayi21.github.io/2018/06/26/hexo建站第一步-1/</id>
    <published>2018-06-26T14:16:33.965Z</published>
    <updated>2020-01-17T04:12:02.356Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.下载git和node.js<br>2.打开GitBash<br>3.下载并安装hexo<a id="more"></a><br>4.新建一个文件夹,hexo inital先初始化一下该目录<br>5.自己找合适的主题<br>6.在git bash中运行<code>hexo g</code>生成本地文件,<code>hexo d</code>将其发布到github上面<br>7.在source/_posts/下面写文章,我用的是MarkdownPad2,只要熟悉一下语法就行<br>day20200117：对帖子进行一下更新：主要是material-x主题支持latex。按照原先的配置下来，是不支持latex的(可能是自身的原因，没有配置好)，然后在捯饬的过程中，有了解决办法。<br>1.应该是主题下面没有math.ejs，但是由于某些问题，没有继续往下面走。<br>2.删除了早先的hexo-renderer-marked引擎<code>npm uninstall hexo-renderer-marked --save</code>，更换为hexo-renderer-kramed引擎<code>npm install hexo-renderer-kramed --save</code>.其次又停止使用hexo-math引擎<code>npm uninstall hexo-math --save</code>,更换为hexo-renderer-mathjax引擎<code>npm install hexo-renderer-mathjax --save</code>.<br>3.打开/node_modules/hexo-renderer-mathjax/mathjax.html文件，将早先最后一行的<script>注释掉，换为即可。<br>4.在主题下启用mathjax引擎<code>mathjax: true</code>，在文章中要开启mathjax引擎，<code>mathjax: true</code>。<br>5.还有关于更改默认转义规则。  </p><hr><p>今天主要谈一下绑定域名<br>1.申请域名,闲着没事干,免费申请了一年的域名,<a href="http://www.freenom.com">freenom</a><br>2.介绍一下主要怎么操作,先“寻找一个新的免费域名”,点击“检查可用性”,会出来一些免费的域名.<br>3.自己选其所好,找到一个加入购物车<br>4.去购物车结帐,都是不要钱的.点击“继续”,<br>5.这时候应该要求填写个人信息,这里提供<a href="https://www.fakenamegenerator.com/">随机生成身份</a>.选择想要的信息.<br>6.邮箱要填自己的,然后邮箱收件箱会收到一封邮件,要求你注册一下.<br>7.你注册好后,在上面网站继续登录.你就会发现你有这个域名了（如果没有,你再搜一下,重新添加进你的购物车）<br>8.有域名后,在你的博客source目录下,添加名字为<code>CNAME</code>（注意没有后缀）的文件,里面的内容就是你的域名.然后<code>hexo g</code>和<code>hexo d</code>下.继而进入DNSPOD把自己的域名解析一下.<br>9.主要先登录,qq,微信都可以.登录上,进入管理控制台,添加自己的域名到域名解析.添加记录的每一项,系统都会提示代表意思,这里主要解释记录类型<br>A记录:地址记录,用来指定域名的IP地址<br>CNAME记录:如果需要将域名指向另一个域名,再由另一个域名提供IP地址,就需要添加CNAME记录<br>NS记录:域名服务器记录,如果需要把子域名交给其他DNS服务商解析,就需要添加NS记录<br>上面的NS记录是系统默认添加的.<br>A记录就是指向对应IP地址,这里的<code>192.30.252.153</code>和<code>192.30.252.154</code>是github的服务器IP地址.<br>CNAME记录这里可填可不填,因为A记录已经将<code>mayi21.tk</code>和<code>mayi21.github.io</code>的域名统一为一个IP地址了<br>有一种情况就是为了提高访问速度,要区分国内国外不同用户使用不同的网站进行重定向需要添加对应的CNAME记录.<br>10.然后继续输入你的<code>name.github.io</code>,就会跳转到你绑定的域名中.</p><hr><p>google收录<br>1.打开<a href="https://www.google.com/webmasters">谷歌搜索引擎验证</a><br>2.输入自己的博客地址,添加属性,我用的是域名服务商验证,把google提供的文本,按照提示添加进入DNSPOD就行了<br>3.点击验证,应该就可以成功了</p></script></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.下载git和node.js&lt;br&gt;2.打开GitBash&lt;br&gt;3.下载并安装hexo
    
    </summary>
    
      <category term="建站" scheme="https://mayi21.github.io/categories/%E5%BB%BA%E7%AB%99/"/>
    
    
      <category term="hexo建站" scheme="https://mayi21.github.io/tags/hexo%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
</feed>
